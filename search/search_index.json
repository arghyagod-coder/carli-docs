{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;"},"docs":[{"location":"","text":"Introduction Goal The goal of this tutorial is to make you learn how to make a Arch Linux based Operating System (also called Distro/Distribution) as an Absolute Beginner. You will be given all of the guide and support as a beginner even if you have no prior experience to Linux. This guide will follow running Arch Linux and understanding Linux Operating system in Detail, and then creating your own distributable Operating System. Subjects we will Cover: Installing Arch Linux Learning Arch Linux Understanding how Linux Works Create an OS based on Arch Linux Get familiarized with common Linux tools and configurations ArchISO Explained Back Office Explained Get ready with a 64-bit CARLI Build Build it Chronologically Arch Linux Installers Investigated Choosing Your Own Desktop Best Practices Explained Calamares Installer Explained Configuring our Desktop Create Your Own Packages Sign Your Packages Add your own Repositories Follow Changes in ArchISO Add AUR Packages to Live ISO Target The documentation is meant as study material for current and future developers of distributions working with Arch Linux. It is meant to be as complete as possible. We mean to read and gather other information from the net and you give a concentrated concoction of knowledge. The end result should be a working iso of Arch Linux at different levels of completion. There are many ways to build an iso. Can we explore them all? Is there a need to? Is there a \u201cbest practice\u201d approach? It is meant to be a long-term project. Releasing a phase/video/article monthly. We need to give the iso a name during our setup. We choose the name \u201cCarli\u201c Carli stands for Customized Arch Linux Iso. The Github Page of ArcoLinuxISO is ready to receive any and all source codes needed for the project.","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#goal","text":"The goal of this tutorial is to make you learn how to make a Arch Linux based Operating System (also called Distro/Distribution) as an Absolute Beginner. You will be given all of the guide and support as a beginner even if you have no prior experience to Linux. This guide will follow running Arch Linux and understanding Linux Operating system in Detail, and then creating your own distributable Operating System.","title":"Goal"},{"location":"#subjects-we-will-cover","text":"Installing Arch Linux Learning Arch Linux Understanding how Linux Works Create an OS based on Arch Linux Get familiarized with common Linux tools and configurations ArchISO Explained Back Office Explained Get ready with a 64-bit CARLI Build Build it Chronologically Arch Linux Installers Investigated Choosing Your Own Desktop Best Practices Explained Calamares Installer Explained Configuring our Desktop Create Your Own Packages Sign Your Packages Add your own Repositories Follow Changes in ArchISO Add AUR Packages to Live ISO","title":"Subjects we will Cover:"},{"location":"#target","text":"The documentation is meant as study material for current and future developers of distributions working with Arch Linux. It is meant to be as complete as possible. We mean to read and gather other information from the net and you give a concentrated concoction of knowledge. The end result should be a working iso of Arch Linux at different levels of completion. There are many ways to build an iso. Can we explore them all? Is there a need to? Is there a \u201cbest practice\u201d approach? It is meant to be a long-term project. Releasing a phase/video/article monthly. We need to give the iso a name during our setup. We choose the name \u201cCarli\u201c Carli stands for Customized Arch Linux Iso. The Github Page of ArcoLinuxISO is ready to receive any and all source codes needed for the project.","title":"Target"},{"location":"distributions/","text":"Examples of Distributions Spun from ArchISO Here are some Spin Off examples influenced by CARLI 1. AmOS 2. AxylOS 3. XelphLinux 4. Carbon UI 5. Aravalli Linux 6. XeroLinux 7. Heftor Linux","title":"Examples of Distributions Spun from ArchISO"},{"location":"distributions/#examples-of-distributions-spun-from-archiso","text":"Here are some Spin Off examples influenced by CARLI 1. AmOS 2. AxylOS 3. XelphLinux 4. Carbon UI 5. Aravalli Linux 6. XeroLinux 7. Heftor Linux","title":"Examples of Distributions Spun from ArchISO"},{"location":"p1/aur/","text":"A Beginner's Guide to the Arch User Repository Though using an Arch-based distro was pretty straightforward for a seasoned user, there is one striking difference that I felt contrasting with the Debian-like environment: the Arch User Repository . This is because Arch Linux separates the official project packages from the software that is contributed by the users themselves in another place completely - thus being called Arch User Repository (AUR). Unlike other distros, however, Arch does not even include them in the reach of your package manager . In Debian or Ubuntu, you might edit /etc/apt/sources.list to add nonfree or \"universe\" repositories or PPAs, and after a cache update, all these packages are automatically manageable from apt. Not so with Arch - the AUR is off-limits to pacman , and you must install software from there in a more \"manual\" way, which confuses many beginners used to a more automatic method. It took me some time to finally get the way installing from the AUR works, not because it's complicated, but rather because I chose to avoid the unknown until I had no choice. And much like the rest of my experience with Arch, it also turned out to be quite easy, even without helpers (yay, yaourt, paru, etc). That's why I'm summarizing the important findings in this point, so that other beginners may not fear the AUR and learn quickly how to install from there. Read on! How AUR works The single largest difference between installing stuff from AUR versus contribution repositories in other distros is this: AUR does not store binary precompiled packages in a server somewhere - you have to build them by yourself . This is strikingly different from, for example, what you see in Debian. There, you download binaries from the repository server, verify the signature to see if it matches the maintainer's, and if all looks good, copy the binaries into their respective places. Finito. With the AUR, that process is almost reversed, following a build process that resembles that of source-based distributions. If you look at it from a purely quantitative perspective, the AUR is a much larger repository than the official Arch packages, and this explains why so many times when you search for something via pacman -Ss package , you'll find nothing, with the answer on the wiki being \"you can install it from the AUR.\" This is especially true when it comes to games: Arch has a myriad of them, arguably larger than any other distro, but few make it to the official repos. Once again, AUR is the answer. The overall install process has four major steps that thankfully can be mostly automated using Arch's tools: Clone the AUR git repository of your desired package. Follow the build instructions of the git repo's PKGBUILD file. Install additional dependencies via pacman. Build from source and install the package via pacman. These steps might sound familiar to you if you've ever compiled a package from the source code on Linux (see my video on SC-IM for an example), and that's because it's exactly what you're doing here. However, unlike the traditional way of building from source, using the AUR allows you to more or less automate most of that process, which greatly facilitates it. That build process also makes use of a \"feigned\" root environment, that makes it unnecessary to run it as the root user (a-la sudo make install), but requires you to install the fakeroot package first: sudo pacman -S fakeroot Let's look at the process more closely now: Installing from AUR Your starting point to install anything from the AUR is to search for the package you want at the AUR database . You have to use your browser for this, as pacman does not search the AUR with the -Ss flag. As you do so, take note of the status and other health indicators of the package; packages in the AUR are not part of the official distribution, and therefore do not get screened for quality or security. Is the package orphaned? Abandoned? Gets regular updates? Do the comments state build errors or difficulties? The more popular packages usually do not suffer from these problems, but it's good to check regardless. Once you decided on the package to install, find its Git repository link and clone it in the terminal. It's presented on the https://aur.archlinux.org/package-name.git format. git clone https://aur.archlinux.org/package-name.git cd package-name/ You'll find that usually the only thing inside the cloned directory is a script named PKGBUILD. This is the \"instructions\" on all the steps required to build that package, all the way from installing dependencies, downloading external assets, and compiler flags. Think of it as a Makefile on steroids, which is great since the next step is to simply run the following command to build and install the package: makepkg -si And that's pretty much it. makepkg does its magic handling all the dependencies and compilation for you (it might ask you to install things via pacman along the way), using fakeroot to abstract parts that would require root permissions to proceed. If you find errors along the way (ie. with the configure script), read them and try to understand what dependencies are missing, and fill in those gaps with pacman. Usually after this the build is pretty smooth. Be warned, though, that since you're compiling everything, it will take much more time compared to pacman. Depending on the package size and your CPU, the build could take anywhere between a few minutes to about an hour. Gentoo users might be used to it, but most others will be quite surprised. Once the package is built, pacman will offer to install it neatly alongside your other system binaries. Enter your password and that's pretty much it - you have installed your first AUR package! Using helpers As seen in this rather simple guide, using the AUR is not at all a hard task once you know how it works behind the scenes. However, it's still not as convenient as having a package manager to search for install and update packages with short, simple commands. Could there be a way to use the AUR in a similar manner? Surprisingly, there are a few, called AUR helpers . A helper program takes the same (or similar) syntax as pacman and abstracts the work described above to provide an experience similar to using pacman itself. There are still a few caveats that the helpers can't cover completely, and the official way to install from the AUR according to the Arch Linux Project remains the manual process described above. But if you take these in consideration, it's still a very convenient way to use the AUR. For the longest time, a program called yaourt was the go-to helper in Arch Linux. It was, however, deprecated due to lack of maintenance sometime in the mid 2010s, and a spiritual successor called yay became the next recommended helper. However, yay itself became deprecated by the end of 2019 due to lack of maintenance, and a few other alternatives came along (I hear that paru is the new successor to yay). This anecdote illustrates one important limitation of helpers: they are as useful as they are maintained. Because they are not an official part of Arch, the project does not maintain them, and they rely on volunteers to keep evolving together with Arch itself. Using a slightly old helper might not be a problem in the short term, but it might stop working as it falls behind the rolling releases. Keep this in mind as you choose which helper to use. As they're not part of of Arch Linux, helpers must (not ironically) also be built and installed from the AUR. As we saw before, though, that is not a problem: just follow the same process to build the package manually with git and once you're done, the helper will be available to you, in parallel to pacman. A full listing comparing all AUR helper programs is available at the Arch Wiki. Conclusion The Arch User Repository is a real treasure trove of community-maintained software that is usually very up-to-date with upstream releases, but requires a slightly different process to install from. Thankfully, it's not complicated, but might require a little more time since it's always built from source. AUR is not without its warts either, and less popular packages might fall behind in terms of quality or even security, and you should always keep this in mind as you install software from it. You can use helper programs (yay, paru, etc) to ease and speed up the build process when installing from the AUR, but keep in mind their limitations and that the official way to install is still manually. If you reckon all of these, the AUR is a terrific tool and a source of a myriad of packages, some of which are not even available in other distributions.","title":"A Beginner's Guide to the Arch User Repository"},{"location":"p1/aur/#a-beginners-guide-to-the-arch-user-repository","text":"Though using an Arch-based distro was pretty straightforward for a seasoned user, there is one striking difference that I felt contrasting with the Debian-like environment: the Arch User Repository . This is because Arch Linux separates the official project packages from the software that is contributed by the users themselves in another place completely - thus being called Arch User Repository (AUR). Unlike other distros, however, Arch does not even include them in the reach of your package manager . In Debian or Ubuntu, you might edit /etc/apt/sources.list to add nonfree or \"universe\" repositories or PPAs, and after a cache update, all these packages are automatically manageable from apt. Not so with Arch - the AUR is off-limits to pacman , and you must install software from there in a more \"manual\" way, which confuses many beginners used to a more automatic method. It took me some time to finally get the way installing from the AUR works, not because it's complicated, but rather because I chose to avoid the unknown until I had no choice. And much like the rest of my experience with Arch, it also turned out to be quite easy, even without helpers (yay, yaourt, paru, etc). That's why I'm summarizing the important findings in this point, so that other beginners may not fear the AUR and learn quickly how to install from there. Read on!","title":"A Beginner's Guide to the Arch User Repository"},{"location":"p1/aur/#how-aur-works","text":"The single largest difference between installing stuff from AUR versus contribution repositories in other distros is this: AUR does not store binary precompiled packages in a server somewhere - you have to build them by yourself . This is strikingly different from, for example, what you see in Debian. There, you download binaries from the repository server, verify the signature to see if it matches the maintainer's, and if all looks good, copy the binaries into their respective places. Finito. With the AUR, that process is almost reversed, following a build process that resembles that of source-based distributions. If you look at it from a purely quantitative perspective, the AUR is a much larger repository than the official Arch packages, and this explains why so many times when you search for something via pacman -Ss package , you'll find nothing, with the answer on the wiki being \"you can install it from the AUR.\" This is especially true when it comes to games: Arch has a myriad of them, arguably larger than any other distro, but few make it to the official repos. Once again, AUR is the answer. The overall install process has four major steps that thankfully can be mostly automated using Arch's tools: Clone the AUR git repository of your desired package. Follow the build instructions of the git repo's PKGBUILD file. Install additional dependencies via pacman. Build from source and install the package via pacman. These steps might sound familiar to you if you've ever compiled a package from the source code on Linux (see my video on SC-IM for an example), and that's because it's exactly what you're doing here. However, unlike the traditional way of building from source, using the AUR allows you to more or less automate most of that process, which greatly facilitates it. That build process also makes use of a \"feigned\" root environment, that makes it unnecessary to run it as the root user (a-la sudo make install), but requires you to install the fakeroot package first: sudo pacman -S fakeroot Let's look at the process more closely now:","title":"How AUR works"},{"location":"p1/aur/#installing-from-aur","text":"Your starting point to install anything from the AUR is to search for the package you want at the AUR database . You have to use your browser for this, as pacman does not search the AUR with the -Ss flag. As you do so, take note of the status and other health indicators of the package; packages in the AUR are not part of the official distribution, and therefore do not get screened for quality or security. Is the package orphaned? Abandoned? Gets regular updates? Do the comments state build errors or difficulties? The more popular packages usually do not suffer from these problems, but it's good to check regardless. Once you decided on the package to install, find its Git repository link and clone it in the terminal. It's presented on the https://aur.archlinux.org/package-name.git format. git clone https://aur.archlinux.org/package-name.git cd package-name/ You'll find that usually the only thing inside the cloned directory is a script named PKGBUILD. This is the \"instructions\" on all the steps required to build that package, all the way from installing dependencies, downloading external assets, and compiler flags. Think of it as a Makefile on steroids, which is great since the next step is to simply run the following command to build and install the package: makepkg -si And that's pretty much it. makepkg does its magic handling all the dependencies and compilation for you (it might ask you to install things via pacman along the way), using fakeroot to abstract parts that would require root permissions to proceed. If you find errors along the way (ie. with the configure script), read them and try to understand what dependencies are missing, and fill in those gaps with pacman. Usually after this the build is pretty smooth. Be warned, though, that since you're compiling everything, it will take much more time compared to pacman. Depending on the package size and your CPU, the build could take anywhere between a few minutes to about an hour. Gentoo users might be used to it, but most others will be quite surprised. Once the package is built, pacman will offer to install it neatly alongside your other system binaries. Enter your password and that's pretty much it - you have installed your first AUR package!","title":"Installing from AUR"},{"location":"p1/aur/#using-helpers","text":"As seen in this rather simple guide, using the AUR is not at all a hard task once you know how it works behind the scenes. However, it's still not as convenient as having a package manager to search for install and update packages with short, simple commands. Could there be a way to use the AUR in a similar manner? Surprisingly, there are a few, called AUR helpers . A helper program takes the same (or similar) syntax as pacman and abstracts the work described above to provide an experience similar to using pacman itself. There are still a few caveats that the helpers can't cover completely, and the official way to install from the AUR according to the Arch Linux Project remains the manual process described above. But if you take these in consideration, it's still a very convenient way to use the AUR. For the longest time, a program called yaourt was the go-to helper in Arch Linux. It was, however, deprecated due to lack of maintenance sometime in the mid 2010s, and a spiritual successor called yay became the next recommended helper. However, yay itself became deprecated by the end of 2019 due to lack of maintenance, and a few other alternatives came along (I hear that paru is the new successor to yay). This anecdote illustrates one important limitation of helpers: they are as useful as they are maintained. Because they are not an official part of Arch, the project does not maintain them, and they rely on volunteers to keep evolving together with Arch itself. Using a slightly old helper might not be a problem in the short term, but it might stop working as it falls behind the rolling releases. Keep this in mind as you choose which helper to use. As they're not part of of Arch Linux, helpers must (not ironically) also be built and installed from the AUR. As we saw before, though, that is not a problem: just follow the same process to build the package manually with git and once you're done, the helper will be available to you, in parallel to pacman. A full listing comparing all AUR helper programs is available at the Arch Wiki.","title":"Using helpers"},{"location":"p1/aur/#conclusion","text":"The Arch User Repository is a real treasure trove of community-maintained software that is usually very up-to-date with upstream releases, but requires a slightly different process to install from. Thankfully, it's not complicated, but might require a little more time since it's always built from source. AUR is not without its warts either, and less popular packages might fall behind in terms of quality or even security, and you should always keep this in mind as you install software from it. You can use helper programs (yay, paru, etc) to ease and speed up the build process when installing from the AUR, but keep in mind their limitations and that the official way to install is still manually. If you reckon all of these, the AUR is a terrific tool and a source of a myriad of packages, some of which are not even available in other distributions.","title":"Conclusion"},{"location":"p1/fs/","text":"The Linux Filesystem Explained Back in 1996 I learned how to install software on my spanking new Linux before really understanding the topography of the filesystem. This turned out to be a problem, not so much for programs, because they would just magically work even though I hadn\u2019t a clue of where the actual executable files landed. The problem was the documentation. You see, back then, Linux was not the intuitive, user-friendly system it is today. You had to read a lot. You had to know things about the frequency rate of your CRT monitor and the ins and outs of your noisy dial-up modem, among hundreds of other things. I soon realized I would need to spend some time getting a handle on how the directories were organized and what all their exotic names like /etc (not for miscellaneous files), /usr (not for user files), and / bin (not a trash can) meant. This tutorial will help you get up to speed faster than I did. Structure It makes sense to explore the Linux filesystem from a terminal window, not because the author is a grumpy old man and resents new kids and their pretty graphical tools \u2014 although there is some truth to that \u2014 but because a terminal, despite being text-only, has better tools to show the map of Linux\u2019s directory tree. In fact, that is the name of the first tool you\u2019ll install to help you on the way: tree . If you are using Ubuntu or Debian, you can do: sudo apt install tree On Red Hat or Fedora, do: sudo dnf install tree For SUSE/openSUSE use zypper : sudo zypper install tree For Arch-like distros (Manjaro, Antergos, etc.) use: sudo pacman -S tree \u2026 and so on. Once installed, stay in your terminal window and run tree like this: tree / The / in the instruction above refers to the root directory. The root directory is the one from which all other directories branch off from. When you run tree and tell it to start with / , you will see the whole directory tree, all directories and all the subdirectories in the whole system, with all their files, fly by. If you have been using your system for some time, this may take a while, because, even if you haven\u2019t generated many files yourself, a Linux system and its apps are always logging, cacheing, and storing temporal files. The number of entries in the file system can grow quite quickly. Don\u2019t feel overwhelmed, though. Instead, try this: tree -L 1 / And you should see what is shown in Figure 1. Figure 1: tree The instruction above can be translated as \u201c show me only the 1st Level of the directory tree starting at / (root) \u201c. The -L option tells tree how many levels down you want to see. Most Linux distributions will show you the same or a very similar layout to what you can see in the image above. This means that even if you feel confused now, master this, and you will have a handle on most, if not all, Linux installations in the whole wide world. To get you started on the road to mastery, let\u2019s look at what each directory is used for. While we go through each, you can peek at their contents using ls . Directories From top to bottom, the directories you are seeing are as follows. /bin /bin is the directory that contains bin aries, that is, some of the applications and programs you can run. You will find the ls program mentioned above in this directory, as well as other basic tools for making and removing files and directories, moving them around, and so on. There are more bin directories in other parts of the file system tree, but we\u2019ll be talking about those in a minute. /boot The /boot directory contains files required for starting your system. Do I have to say this? Okay, I\u2019ll say it: DO NOT TOUCH! . If you mess up one of the files in here, you may not be able to run your Linux and it is a pain to repair. On the other hand, don\u2019t worry too much about destroying your system by accident: you have to have superuser privileges to do that. /dev /dev contains dev ice files. Many of these are generated at boot time or even on the fly. For example, if you plug in a new webcam or a USB pendrive into your machine, a new device entry will automagically pop up here. /etc /etc is the directory where names start to get confusing. /etc gets its name from the earliest Unixes and it was literally \u201cet cetera\u201d because it was the dumping ground for system files administrators were not sure where else to put. Nowadays, it would be more appropriate to say that etc stands for \u201cEverything to configure,\u201d as it contains most, if not all system-wide configuration files. For example, the files that contain the name of your system, the users and their passwords, the names of machines on your network and when and where the partitions on your hard disks should be mounted are all in here. Again, if you are new to Linux, it may be best if you don\u2019t touch too much in here until you have a better understanding of how things work. /home /home is where you will find your users\u2019 personal directories. In my case, under /home there are two directories: /home/paul , which contains all my stuff; and /home/guest , in case anybody needs to borrow my computer. /lib /lib is where lib raries live. Libraries are files containing code that your applications can use. They contain snippets of code that applications use to draw windows on your desktop, control peripherals, or send files to your hard disk. There are more lib directories scattered around the file system, but this one, the one hanging directly off of / is special in that, among other things, it contains the all-important kernel modules. The kernel modules are drivers that make things like your video card, sound card, WiFi, printer, and so on, work. /media The /media directory is where external storage will be automatically mounted when you plug it in and try to access it. As opposed to most of the other items on this list, /media does not hail back to 1970s, mainly because inserting and detecting storage (pendrives, USB hard disks, SD cards, external SSDs, etc) on the fly, while a computer is running, is a relatively new thing. /mnt The /mnt directory, however, is a bit of remnant from days gone by. This is where you would manually mount storage devices or partitions. It is not used very often nowadays. /opt The /opt directory is often where software you compile (that is, you build yourself from source code and do not install from your distribution repositories) sometimes lands. Applications will end up in the /opt/bin directory and libraries in the /opt/lib directory. A slight digression: another place where applications and libraries end up in is /usr/local , When software gets installed here, there will also be /usr/local/bin and /usr/local/lib directories. What determines which software goes where is how the developers have configured the files that control the compilation and installation process. /proc /proc , like /dev is a virtual directory. It contains information about your computer, such as information about your CPU and the kernel your Linux system is running. As with /dev , the files and directories are generated when your computer starts, or on the fly, as your system is running and things change. /root /root is the home directory of the superuser (also known as the \u201cAdministrator\u201d) of the system. It is separate from the rest of the users\u2019 home directories BECAUSE YOU ARE NOT MEANT TO TOUCH IT. Keep your own stuff in you own directories, people. /run /run is another new directory. System processes use it to store temporary data for their own nefarious reasons. This is another one of those DO NOT TOUCH folders. /sbin /sbin is similar to /bin , but it contains applications that only the superuser (hence the initial s ) will need. You can use these applications with the sudo command that temporarily concedes you superuser powers on many distributions. /sbin typically contains tools that can install stuff, delete stuff and format stuff. As you can imagine, some of these instructions are lethal if you use them improperly, so handle with care. /usr The /usr directory was where users\u2019 home directories were originally kept back in the early days of UNIX. However, now /home is where users kept their stuff as we saw above. These days, /usr contains a mish-mash of directories which in turn contain applications, libraries, documentation, wallpapers, icons and a long list of other stuff that need to be shared by applications and services. You will also find bin , sbin and lib directories in /usr . What is the difference with their root-hanging cousins? Not much nowadays. Originally, the /bin directory (hanging off of root) would contain very basic commands, like ls , mv and rm ; the kind of commands that would come pre-installed in all UNIX/Linux installations, the bare minimum to run and maintain a system. /usr/bin on the other hand would contain stuff the users would install and run to use the system as a work station, things like word processors, web browsers, and other apps. But many modern Linux distributions just put everything into /usr/bin and have /bin point to /usr/bin just in case erasing it completely would break something. So, while Debian, Ubuntu and Mint still keep /bin and /usr/bin (and /sbin and /usr/sbin ) separate; others, like Arch and its derivatives just have one \u201creal\u201d directory for binaries, /usr/bin , and the rest or bin s are \u201cfake\u201d directories that point to /usr/bin*. /srv The /srv directory contains data for servers. If you are running a web server from your Linux box, your HTML files for your sites would go into /srv/http (or /srv/www ). If you were running an FTP server, your files would go into /srv/ftp . /sys /sys is another virtual directory like /proc and /dev and also contains information from devices connected to your computer. In some cases you can also manipulate those devices. I can, for example, change the brightness of the screen of my laptop by modifying the value stored in the /sys/devices/pci0000:00/0000:00:02.0/drm/card1/card1-eDP-1/intel_backlight/brightness file (on your machine you will probably have a different file). But to do that you have to become superuser. The reason for that is, as with so many other virtual directories, messing with the contents and files in /sys can be dangerous and you can trash your system. DO NOT TOUCH until you are sure you know what you are doing. /tmp /tmp contains temporary files, usually placed there by applications that you are running. The files and directories often (not always) contain data that an application doesn\u2019t need right now, but may need later on. You can also use /tmp to store your own temporary files \u2014 /tmp is one of the few directories hanging off / that you can actually interact with without becoming superuser. /var /var was originally given its name because its contents was deemed variable , in that it changed frequently. Today it is a bit of a misnomer because there are many other directories that also contain data that changes frequently, especially the virtual directories we saw above. Be that as it may, /var contains things like logs in the /var/log subdirectories. Logs are files that register events that happen on the system. If something fails in the kernel, it will be logged in a file in /var/log ; if someone tries to break into your computer from outside, your firewall will also log the attempt here. It also contains spools for tasks. These \u201ctasks\u201d can be the jobs you send to a shared printer when you have to wait because another user is printing a long document, or mail that is waiting to be delivered to users on the system. Your system may have some more directories we haven\u2019t mentioned above. In the screenshot, for example, there is a /snap directory. That\u2019s because the shot was captured on an Ubuntu system. Ubuntu has recently incorporated snap packages as a way of distributing software. The /snap directory contains all the files and the software installed from snaps. Digging Deeper That is the root directory covered, but many of the subdirectories lead to their own set of files and subdirectories. Figure 2 gives you an overall idea of what the basic file system tree looks like (the image is kindly supplied under a CC By-SA license by Paul Gardner) and Wikipedia has a break down with a summary of what each directory is used for . Figure 2: Standard Unix filesystem hierarchy. To explore the filesystem yourself, use the cd command: cd will take you to the directory of your choice ( cd stands for change directory . If you get confused, pwd will always tell you where you ( pwd stands for print working directory ). Also, cd with no options or parameters, will take you back to your own home directory, where things are safe and cosy. Finally, cd .. will take you up one level, getting you one level closer to the / root directory. If you are in /usr/share/wallpapers and run cd .. , you will move up to /usr/share . To see what a directory contains, use ls or simply ls to list the contents of the directory you are in right now. And, of course, you always have tree to get an overview of what lays within a directory. Try it on /usr/share \u2014 there is a lot of interesting stuff in there. Conclusion Although there are minor differences between Linux distributions, the layout for their filesystems are mercifully similar. So much so that you could say: once you know one, you know them all. And the best way to know the filesystem is to explore it. So go forth with tree , ls , and cd into uncharted territory. You cannot damage your filesystem just by looking at it, so move from one directory to another and take a look around. Soon you\u2019ll discover that the Linux filesystem and how it is laid out really makes a lot of sense, and you will intuitively know where to find apps, documentation, and other resources.","title":"The Linux Filesystem Explained"},{"location":"p1/fs/#the-linux-filesystem-explained","text":"Back in 1996 I learned how to install software on my spanking new Linux before really understanding the topography of the filesystem. This turned out to be a problem, not so much for programs, because they would just magically work even though I hadn\u2019t a clue of where the actual executable files landed. The problem was the documentation. You see, back then, Linux was not the intuitive, user-friendly system it is today. You had to read a lot. You had to know things about the frequency rate of your CRT monitor and the ins and outs of your noisy dial-up modem, among hundreds of other things. I soon realized I would need to spend some time getting a handle on how the directories were organized and what all their exotic names like /etc (not for miscellaneous files), /usr (not for user files), and / bin (not a trash can) meant. This tutorial will help you get up to speed faster than I did.","title":"The Linux Filesystem Explained"},{"location":"p1/fs/#structure","text":"It makes sense to explore the Linux filesystem from a terminal window, not because the author is a grumpy old man and resents new kids and their pretty graphical tools \u2014 although there is some truth to that \u2014 but because a terminal, despite being text-only, has better tools to show the map of Linux\u2019s directory tree. In fact, that is the name of the first tool you\u2019ll install to help you on the way: tree . If you are using Ubuntu or Debian, you can do: sudo apt install tree On Red Hat or Fedora, do: sudo dnf install tree For SUSE/openSUSE use zypper : sudo zypper install tree For Arch-like distros (Manjaro, Antergos, etc.) use: sudo pacman -S tree \u2026 and so on. Once installed, stay in your terminal window and run tree like this: tree / The / in the instruction above refers to the root directory. The root directory is the one from which all other directories branch off from. When you run tree and tell it to start with / , you will see the whole directory tree, all directories and all the subdirectories in the whole system, with all their files, fly by. If you have been using your system for some time, this may take a while, because, even if you haven\u2019t generated many files yourself, a Linux system and its apps are always logging, cacheing, and storing temporal files. The number of entries in the file system can grow quite quickly. Don\u2019t feel overwhelmed, though. Instead, try this: tree -L 1 / And you should see what is shown in Figure 1. Figure 1: tree The instruction above can be translated as \u201c show me only the 1st Level of the directory tree starting at / (root) \u201c. The -L option tells tree how many levels down you want to see. Most Linux distributions will show you the same or a very similar layout to what you can see in the image above. This means that even if you feel confused now, master this, and you will have a handle on most, if not all, Linux installations in the whole wide world. To get you started on the road to mastery, let\u2019s look at what each directory is used for. While we go through each, you can peek at their contents using ls .","title":"Structure"},{"location":"p1/fs/#directories","text":"From top to bottom, the directories you are seeing are as follows.","title":"Directories"},{"location":"p1/fs/#bin","text":"/bin is the directory that contains bin aries, that is, some of the applications and programs you can run. You will find the ls program mentioned above in this directory, as well as other basic tools for making and removing files and directories, moving them around, and so on. There are more bin directories in other parts of the file system tree, but we\u2019ll be talking about those in a minute.","title":"/bin"},{"location":"p1/fs/#boot","text":"The /boot directory contains files required for starting your system. Do I have to say this? Okay, I\u2019ll say it: DO NOT TOUCH! . If you mess up one of the files in here, you may not be able to run your Linux and it is a pain to repair. On the other hand, don\u2019t worry too much about destroying your system by accident: you have to have superuser privileges to do that.","title":"/boot"},{"location":"p1/fs/#dev","text":"/dev contains dev ice files. Many of these are generated at boot time or even on the fly. For example, if you plug in a new webcam or a USB pendrive into your machine, a new device entry will automagically pop up here.","title":"/dev"},{"location":"p1/fs/#etc","text":"/etc is the directory where names start to get confusing. /etc gets its name from the earliest Unixes and it was literally \u201cet cetera\u201d because it was the dumping ground for system files administrators were not sure where else to put. Nowadays, it would be more appropriate to say that etc stands for \u201cEverything to configure,\u201d as it contains most, if not all system-wide configuration files. For example, the files that contain the name of your system, the users and their passwords, the names of machines on your network and when and where the partitions on your hard disks should be mounted are all in here. Again, if you are new to Linux, it may be best if you don\u2019t touch too much in here until you have a better understanding of how things work.","title":"/etc"},{"location":"p1/fs/#home","text":"/home is where you will find your users\u2019 personal directories. In my case, under /home there are two directories: /home/paul , which contains all my stuff; and /home/guest , in case anybody needs to borrow my computer.","title":"/home"},{"location":"p1/fs/#lib","text":"/lib is where lib raries live. Libraries are files containing code that your applications can use. They contain snippets of code that applications use to draw windows on your desktop, control peripherals, or send files to your hard disk. There are more lib directories scattered around the file system, but this one, the one hanging directly off of / is special in that, among other things, it contains the all-important kernel modules. The kernel modules are drivers that make things like your video card, sound card, WiFi, printer, and so on, work.","title":"/lib"},{"location":"p1/fs/#media","text":"The /media directory is where external storage will be automatically mounted when you plug it in and try to access it. As opposed to most of the other items on this list, /media does not hail back to 1970s, mainly because inserting and detecting storage (pendrives, USB hard disks, SD cards, external SSDs, etc) on the fly, while a computer is running, is a relatively new thing.","title":"/media"},{"location":"p1/fs/#mnt","text":"The /mnt directory, however, is a bit of remnant from days gone by. This is where you would manually mount storage devices or partitions. It is not used very often nowadays.","title":"/mnt"},{"location":"p1/fs/#opt","text":"The /opt directory is often where software you compile (that is, you build yourself from source code and do not install from your distribution repositories) sometimes lands. Applications will end up in the /opt/bin directory and libraries in the /opt/lib directory. A slight digression: another place where applications and libraries end up in is /usr/local , When software gets installed here, there will also be /usr/local/bin and /usr/local/lib directories. What determines which software goes where is how the developers have configured the files that control the compilation and installation process.","title":"/opt"},{"location":"p1/fs/#proc","text":"/proc , like /dev is a virtual directory. It contains information about your computer, such as information about your CPU and the kernel your Linux system is running. As with /dev , the files and directories are generated when your computer starts, or on the fly, as your system is running and things change.","title":"/proc"},{"location":"p1/fs/#root","text":"/root is the home directory of the superuser (also known as the \u201cAdministrator\u201d) of the system. It is separate from the rest of the users\u2019 home directories BECAUSE YOU ARE NOT MEANT TO TOUCH IT. Keep your own stuff in you own directories, people.","title":"/root"},{"location":"p1/fs/#run","text":"/run is another new directory. System processes use it to store temporary data for their own nefarious reasons. This is another one of those DO NOT TOUCH folders.","title":"/run"},{"location":"p1/fs/#sbin","text":"/sbin is similar to /bin , but it contains applications that only the superuser (hence the initial s ) will need. You can use these applications with the sudo command that temporarily concedes you superuser powers on many distributions. /sbin typically contains tools that can install stuff, delete stuff and format stuff. As you can imagine, some of these instructions are lethal if you use them improperly, so handle with care.","title":"/sbin"},{"location":"p1/fs/#usr","text":"The /usr directory was where users\u2019 home directories were originally kept back in the early days of UNIX. However, now /home is where users kept their stuff as we saw above. These days, /usr contains a mish-mash of directories which in turn contain applications, libraries, documentation, wallpapers, icons and a long list of other stuff that need to be shared by applications and services. You will also find bin , sbin and lib directories in /usr . What is the difference with their root-hanging cousins? Not much nowadays. Originally, the /bin directory (hanging off of root) would contain very basic commands, like ls , mv and rm ; the kind of commands that would come pre-installed in all UNIX/Linux installations, the bare minimum to run and maintain a system. /usr/bin on the other hand would contain stuff the users would install and run to use the system as a work station, things like word processors, web browsers, and other apps. But many modern Linux distributions just put everything into /usr/bin and have /bin point to /usr/bin just in case erasing it completely would break something. So, while Debian, Ubuntu and Mint still keep /bin and /usr/bin (and /sbin and /usr/sbin ) separate; others, like Arch and its derivatives just have one \u201creal\u201d directory for binaries, /usr/bin , and the rest or bin s are \u201cfake\u201d directories that point to /usr/bin*.","title":"/usr"},{"location":"p1/fs/#srv","text":"The /srv directory contains data for servers. If you are running a web server from your Linux box, your HTML files for your sites would go into /srv/http (or /srv/www ). If you were running an FTP server, your files would go into /srv/ftp .","title":"/srv"},{"location":"p1/fs/#sys","text":"/sys is another virtual directory like /proc and /dev and also contains information from devices connected to your computer. In some cases you can also manipulate those devices. I can, for example, change the brightness of the screen of my laptop by modifying the value stored in the /sys/devices/pci0000:00/0000:00:02.0/drm/card1/card1-eDP-1/intel_backlight/brightness file (on your machine you will probably have a different file). But to do that you have to become superuser. The reason for that is, as with so many other virtual directories, messing with the contents and files in /sys can be dangerous and you can trash your system. DO NOT TOUCH until you are sure you know what you are doing.","title":"/sys"},{"location":"p1/fs/#tmp","text":"/tmp contains temporary files, usually placed there by applications that you are running. The files and directories often (not always) contain data that an application doesn\u2019t need right now, but may need later on. You can also use /tmp to store your own temporary files \u2014 /tmp is one of the few directories hanging off / that you can actually interact with without becoming superuser.","title":"/tmp"},{"location":"p1/fs/#var","text":"/var was originally given its name because its contents was deemed variable , in that it changed frequently. Today it is a bit of a misnomer because there are many other directories that also contain data that changes frequently, especially the virtual directories we saw above. Be that as it may, /var contains things like logs in the /var/log subdirectories. Logs are files that register events that happen on the system. If something fails in the kernel, it will be logged in a file in /var/log ; if someone tries to break into your computer from outside, your firewall will also log the attempt here. It also contains spools for tasks. These \u201ctasks\u201d can be the jobs you send to a shared printer when you have to wait because another user is printing a long document, or mail that is waiting to be delivered to users on the system. Your system may have some more directories we haven\u2019t mentioned above. In the screenshot, for example, there is a /snap directory. That\u2019s because the shot was captured on an Ubuntu system. Ubuntu has recently incorporated snap packages as a way of distributing software. The /snap directory contains all the files and the software installed from snaps.","title":"/var"},{"location":"p1/fs/#digging-deeper","text":"That is the root directory covered, but many of the subdirectories lead to their own set of files and subdirectories. Figure 2 gives you an overall idea of what the basic file system tree looks like (the image is kindly supplied under a CC By-SA license by Paul Gardner) and Wikipedia has a break down with a summary of what each directory is used for . Figure 2: Standard Unix filesystem hierarchy. To explore the filesystem yourself, use the cd command: cd will take you to the directory of your choice ( cd stands for change directory . If you get confused, pwd will always tell you where you ( pwd stands for print working directory ). Also, cd with no options or parameters, will take you back to your own home directory, where things are safe and cosy. Finally, cd .. will take you up one level, getting you one level closer to the / root directory. If you are in /usr/share/wallpapers and run cd .. , you will move up to /usr/share . To see what a directory contains, use ls or simply ls to list the contents of the directory you are in right now. And, of course, you always have tree to get an overview of what lays within a directory. Try it on /usr/share \u2014 there is a lot of interesting stuff in there.","title":"Digging Deeper"},{"location":"p1/fs/#conclusion","text":"Although there are minor differences between Linux distributions, the layout for their filesystems are mercifully similar. So much so that you could say: once you know one, you know them all. And the best way to know the filesystem is to explore it. So go forth with tree , ls , and cd into uncharted territory. You cannot damage your filesystem just by looking at it, so move from one directory to another and take a look around. Soon you\u2019ll discover that the Linux filesystem and how it is laid out really makes a lot of sense, and you will intuitively know where to find apps, documentation, and other resources.","title":"Conclusion"},{"location":"p1/installm/","text":"Install Arch Linux with Calam-Arch As this tutorial is made for beginners, we use the Calam Arch installer. It is an excellent tool that can install vanilla Arch Linux with ease, rather than via the command line. Here\u2019s how to use it. Note: The Calam Arch Linux installer ISO requires at least 1 GB of space. For best results, use a 1 GB USB flash drive or larger. Alternatively, burning an ISO file to a DVD also works, though DVD instructions are not covered in this guide. Downloading Calam Arch ISO The Calam Arch ISO installer is available for download on the project\u2019s SourceForge page. To download the latest release of the ISO installer to your computer, do the following. First, head over to the Calam Arch SourceForge page . Once on the page, locate the green \u201cDownload\u201d button. When you select this button, the Calam Arch ISO file will begin to download. Alternatively, if you need an older release of the Calam Arch installer, find the \u201cFiles\u201d tab, select it. Then, click on the \u201cFiles\u201d folder to check out older releases of the installer. Installing Calam Arch on VirtualBox Warning Use this method ONLY IF you are gonna install Arch in a Virtual Machine Undoubtedly, you need to first install VirtualBox on Linux or Windows. On Windows, simply go to the Oracle\u2019s website and download VirtualBox. Download VirtualBox If you are using Windows 10 or newer version, please ensure that you have virtualization enabled on your system. Keep your downloaded ISO ready. Part 1. Creating the Virtual Machine Step 1: First, you need to set up a few things in VirtualBox. Launch VirtualBox and click on \u201c New \u201d to create a virtual machine. Note that you can continue creating the virtual machine using the guided mode, but you get more options at a single glance with the expert mode. Hence, I recommend using the expert mode to create the virtual machine. Fret not, the expert mode is as easy, with just a bit of extra available options and nothing else to worry about. Step 2 : Enter the name of your virtual machine, it should auto-detect the \u201cType\u201d and \u201cVersion\u201d respectively when you type in \u201c Arch Linux \u201d in the name field. You should increase the memory size to use the virtual machine comfortably. If it is just for minor testing, you can go ahead with the default setting. In my case, I allocate ~ 4 GB of RAM . Also, make sure to create a virtual hard disk under the \u201cHard disk\u201d option. It should be the selected option by default. Now, proceed to set the virtual hard disk size. Step 3: You can choose a preferred location path for the virtual hard disk and tweak the size as per your requirements. The installation should not be a problem with the minimum allocated size (8 GB), but to be on the safe side, you may want to allocate at least 10-15 GB. Next, you need to select the hard disk file type as \u201c VDI (VirtualBox Disk Image) \u201d and the storage as \u201c Dynamically allocated ,\u201d as shown in the image above. VDI is the most common hard disk type for the virtual hard disk. And, when you select the \u201c Dynamically allocated \u201d option for the hard disk storage, it means that the storage space will be utilized as per usage. In other words, 15 GB of space won\u2019t be locked from your disk as soon as the virtual machine is created. Now, all you have to do is hit \u201c Create \u201d to add the virtual machine. Part 2. Adding the ISO File to Start Installing Arch Linux Once the VM has been listed, you can look at its configuration and select the ISO as the disk drive under the Storage option. You can also separately head to the virtual machine settings to explore more and choose the ISO file. To do that, navigate your way to the \u201c Storage \u201d setting of the VM. Here, you will have to click on the \u201c Empty \u201d device under Controller and then proceed to select the Calam-Arch ISO file as the disk file (as shown in the image above). My ISO's name is archlinux-date-arch.iso but your might be something else, according to what you have downloaded Once you select it, hit \u201c OK \u201d to save the changes to your setting. Here\u2019s how the virtual machine setting should look like with the ISO set as the disk to boot: Now, hit \u201c Start \u201d to start the VM and get started with the installation. Then start the VM, you'll boot into Calam-Arch Creating Calam Arch USB installer Warning Use this method ONLY IF you are gonna install Arch in real hardware The Calam Arch installer ISO file needs to be flashed to a USB flash drive. There are many ways to create a USB flash drive with an ISO file. In this guide, we\u2019ll focus on the Etcher application. Why Etcher? It is cross-platform. So, no matter what operating system you flash the Calam Arch ISO file to, the instructions are the same. To get your hands on the Etcher application, head over to the official website. Download Etcher and install it on your computer. After installing the Etcher application on your computer, open it up and follow the step-by-step instructions below to make your Calam Arch USB installer. Step 1: Select the \u201cFlash from file\u201d button with the mouse. When you click on this button, a pop-up menu will appear on the screen. Using the menu, locate the Calam Arch ISO file on your computer and select it. Step 2: Find the \u201cSelect target\u201d button with the mouse. Then, choose the USB flash drive you wish to install the Calam Arch ISO file to. Step 3: Click on the \u201cFlash!\u201d button in the Etcher application to start the flashing process. This process will take quite a bit of time, so be patient. When it is complete, close Etcher. After closing the Etcher application, reboot the computer you plan to install Arch Linux on. Then, boot into the BIOS and configure it to boot from the USB flash drive. Installing Arch Linux with Calam Arch To install Arch Linux with Calam Arch, start by clicking on the black Arch Linux logo on the desktop. Then, follow the step-by-step instructions below. Step 1: Allow the Calam installer to launch on the desktop. Then, on the installer\u2019s welcome page, find your preferred language. Then, click on the \u201cNext\u201d button to move to the next page in the installer. Step 2: After selecting your language, you\u2019ll need to select your timezone. Using the on-screen map, choose your preferred timezone. Or, use the drop-down menus to choose your timezone. Click \u201cNext\u201d to continue to the next page. Step 3: You\u2019ll now need to select your keyboard layout. Using the on-screen menu, find the keyboard layout you prefer. Or leave it as default, as the Calam Arch installer should automatically detect it. Click the \u201cNext\u201d button to move to the next page. Step 4: Once the keyboard is configured, it is time to choose your partitioning method. Select \u201cInstall alongside\u201d if you prefer to dual-boot with Windows. Or, if you wish to erase the hard drive, select the \u201cErase disk\u201d option. If you are using a Virtual Machine, then just use \"Erase Disk\" option When done, click the \u201cNext\u201d button. Step 5: Following the partition setup, you\u2019ll need to choose packages you wish to install with the new Arch Linux installation. Go through the list, choose your preferred desktop environment, graphics driver preferences, printer support (if needed), and other things. Package Information: Base-Devel + Common Packages - Select this always GeForce GTX-RTX Closed Drivers - Select this if you have a Nvidia GPU and you are not using a virtual machine. GeForce Open Drivers - Select this if you have a Nvidia GPU and you are not using a virtual machine. AMD Video Drivers - Select this if you have an AMD GPU and you are not using a virtual machine. Intel Video Drivers - Select this if you have a Intel Integrated GPU and you are not using a virtual machine. Now time to choose your desktop interface: XFCE4 Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: GNOME Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: KDE Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: Cinnamon Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: Budgie Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: Deepin Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: All of the desktops are customizable and can be customized your own way. I personally recommend KDE or GNOME. KDE is light and also the most customizable desktop. Printing Support - Select this to get Printing Support on your machine. This is preferred when you install Arch Linux in real hardware. Web Browsers - Select your favourite web browser (I recommend firefox) from the drop down list. When all packages are selected, click the \u201cNext\u201d button to confirm your choice. Step 6: After setting up your packages for the Calam Arch Linux installer, you\u2019ll have to set up your user account. First, write in your name in the \u201cWhat is your name box.\u201d Then, configure your username, and the name of your computer. After setting up your name, username, and computer name, enter your password. Be sure to enter in a secure, memorable password. Click on the \u201cNext\u201d button to move to the next step in the installer. Step 7: Following setting up your username, the Calam Arch installer will show a summary of your installation. Look it over and make sure everything looks good. When done, click on the \u201cInstall\u201d button at the bottom of the page to install the operating system onto your computer. When the installation is complete, unplug your USB flash drive and reboot. Upon rebooting, Arch Linux will be ready to use. Enjoy! Note To reboot on VirtualBox, remove the Optical ISO image we added in the \"Storage\" section of Settings. Reference Video Links Installing Calam-Arch on VirtualBox","title":"Install Arch Linux with Calam-Arch"},{"location":"p1/installm/#install-arch-linux-with-calam-arch","text":"As this tutorial is made for beginners, we use the Calam Arch installer. It is an excellent tool that can install vanilla Arch Linux with ease, rather than via the command line. Here\u2019s how to use it. Note: The Calam Arch Linux installer ISO requires at least 1 GB of space. For best results, use a 1 GB USB flash drive or larger. Alternatively, burning an ISO file to a DVD also works, though DVD instructions are not covered in this guide.","title":"Install Arch Linux with Calam-Arch"},{"location":"p1/installm/#downloading-calam-arch-iso","text":"The Calam Arch ISO installer is available for download on the project\u2019s SourceForge page. To download the latest release of the ISO installer to your computer, do the following. First, head over to the Calam Arch SourceForge page . Once on the page, locate the green \u201cDownload\u201d button. When you select this button, the Calam Arch ISO file will begin to download. Alternatively, if you need an older release of the Calam Arch installer, find the \u201cFiles\u201d tab, select it. Then, click on the \u201cFiles\u201d folder to check out older releases of the installer.","title":"Downloading Calam Arch ISO"},{"location":"p1/installm/#installing-calam-arch-on-virtualbox","text":"Warning Use this method ONLY IF you are gonna install Arch in a Virtual Machine Undoubtedly, you need to first install VirtualBox on Linux or Windows. On Windows, simply go to the Oracle\u2019s website and download VirtualBox. Download VirtualBox If you are using Windows 10 or newer version, please ensure that you have virtualization enabled on your system. Keep your downloaded ISO ready.","title":"Installing Calam Arch on VirtualBox"},{"location":"p1/installm/#part-1-creating-the-virtual-machine","text":"Step 1: First, you need to set up a few things in VirtualBox. Launch VirtualBox and click on \u201c New \u201d to create a virtual machine. Note that you can continue creating the virtual machine using the guided mode, but you get more options at a single glance with the expert mode. Hence, I recommend using the expert mode to create the virtual machine. Fret not, the expert mode is as easy, with just a bit of extra available options and nothing else to worry about. Step 2 : Enter the name of your virtual machine, it should auto-detect the \u201cType\u201d and \u201cVersion\u201d respectively when you type in \u201c Arch Linux \u201d in the name field. You should increase the memory size to use the virtual machine comfortably. If it is just for minor testing, you can go ahead with the default setting. In my case, I allocate ~ 4 GB of RAM . Also, make sure to create a virtual hard disk under the \u201cHard disk\u201d option. It should be the selected option by default. Now, proceed to set the virtual hard disk size. Step 3: You can choose a preferred location path for the virtual hard disk and tweak the size as per your requirements. The installation should not be a problem with the minimum allocated size (8 GB), but to be on the safe side, you may want to allocate at least 10-15 GB. Next, you need to select the hard disk file type as \u201c VDI (VirtualBox Disk Image) \u201d and the storage as \u201c Dynamically allocated ,\u201d as shown in the image above. VDI is the most common hard disk type for the virtual hard disk. And, when you select the \u201c Dynamically allocated \u201d option for the hard disk storage, it means that the storage space will be utilized as per usage. In other words, 15 GB of space won\u2019t be locked from your disk as soon as the virtual machine is created. Now, all you have to do is hit \u201c Create \u201d to add the virtual machine.","title":"Part 1. Creating the Virtual Machine"},{"location":"p1/installm/#part-2-adding-the-iso-file-to-start-installing-arch-linux","text":"Once the VM has been listed, you can look at its configuration and select the ISO as the disk drive under the Storage option. You can also separately head to the virtual machine settings to explore more and choose the ISO file. To do that, navigate your way to the \u201c Storage \u201d setting of the VM. Here, you will have to click on the \u201c Empty \u201d device under Controller and then proceed to select the Calam-Arch ISO file as the disk file (as shown in the image above). My ISO's name is archlinux-date-arch.iso but your might be something else, according to what you have downloaded Once you select it, hit \u201c OK \u201d to save the changes to your setting. Here\u2019s how the virtual machine setting should look like with the ISO set as the disk to boot: Now, hit \u201c Start \u201d to start the VM and get started with the installation. Then start the VM, you'll boot into Calam-Arch","title":"Part 2. Adding the ISO File to Start Installing Arch Linux"},{"location":"p1/installm/#creating-calam-arch-usb-installer","text":"Warning Use this method ONLY IF you are gonna install Arch in real hardware The Calam Arch installer ISO file needs to be flashed to a USB flash drive. There are many ways to create a USB flash drive with an ISO file. In this guide, we\u2019ll focus on the Etcher application. Why Etcher? It is cross-platform. So, no matter what operating system you flash the Calam Arch ISO file to, the instructions are the same. To get your hands on the Etcher application, head over to the official website. Download Etcher and install it on your computer. After installing the Etcher application on your computer, open it up and follow the step-by-step instructions below to make your Calam Arch USB installer. Step 1: Select the \u201cFlash from file\u201d button with the mouse. When you click on this button, a pop-up menu will appear on the screen. Using the menu, locate the Calam Arch ISO file on your computer and select it. Step 2: Find the \u201cSelect target\u201d button with the mouse. Then, choose the USB flash drive you wish to install the Calam Arch ISO file to. Step 3: Click on the \u201cFlash!\u201d button in the Etcher application to start the flashing process. This process will take quite a bit of time, so be patient. When it is complete, close Etcher. After closing the Etcher application, reboot the computer you plan to install Arch Linux on. Then, boot into the BIOS and configure it to boot from the USB flash drive.","title":"Creating Calam Arch USB installer"},{"location":"p1/installm/#installing-arch-linux-with-calam-arch","text":"To install Arch Linux with Calam Arch, start by clicking on the black Arch Linux logo on the desktop. Then, follow the step-by-step instructions below. Step 1: Allow the Calam installer to launch on the desktop. Then, on the installer\u2019s welcome page, find your preferred language. Then, click on the \u201cNext\u201d button to move to the next page in the installer. Step 2: After selecting your language, you\u2019ll need to select your timezone. Using the on-screen map, choose your preferred timezone. Or, use the drop-down menus to choose your timezone. Click \u201cNext\u201d to continue to the next page. Step 3: You\u2019ll now need to select your keyboard layout. Using the on-screen menu, find the keyboard layout you prefer. Or leave it as default, as the Calam Arch installer should automatically detect it. Click the \u201cNext\u201d button to move to the next page. Step 4: Once the keyboard is configured, it is time to choose your partitioning method. Select \u201cInstall alongside\u201d if you prefer to dual-boot with Windows. Or, if you wish to erase the hard drive, select the \u201cErase disk\u201d option. If you are using a Virtual Machine, then just use \"Erase Disk\" option When done, click the \u201cNext\u201d button. Step 5: Following the partition setup, you\u2019ll need to choose packages you wish to install with the new Arch Linux installation. Go through the list, choose your preferred desktop environment, graphics driver preferences, printer support (if needed), and other things. Package Information: Base-Devel + Common Packages - Select this always GeForce GTX-RTX Closed Drivers - Select this if you have a Nvidia GPU and you are not using a virtual machine. GeForce Open Drivers - Select this if you have a Nvidia GPU and you are not using a virtual machine. AMD Video Drivers - Select this if you have an AMD GPU and you are not using a virtual machine. Intel Video Drivers - Select this if you have a Intel Integrated GPU and you are not using a virtual machine. Now time to choose your desktop interface: XFCE4 Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: GNOME Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: KDE Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: Cinnamon Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: Budgie Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: Deepin Desktop - Select this if you want the XFCE Desktop Environment. XFCE Desktop looks like the following: All of the desktops are customizable and can be customized your own way. I personally recommend KDE or GNOME. KDE is light and also the most customizable desktop. Printing Support - Select this to get Printing Support on your machine. This is preferred when you install Arch Linux in real hardware. Web Browsers - Select your favourite web browser (I recommend firefox) from the drop down list. When all packages are selected, click the \u201cNext\u201d button to confirm your choice. Step 6: After setting up your packages for the Calam Arch Linux installer, you\u2019ll have to set up your user account. First, write in your name in the \u201cWhat is your name box.\u201d Then, configure your username, and the name of your computer. After setting up your name, username, and computer name, enter your password. Be sure to enter in a secure, memorable password. Click on the \u201cNext\u201d button to move to the next step in the installer. Step 7: Following setting up your username, the Calam Arch installer will show a summary of your installation. Look it over and make sure everything looks good. When done, click on the \u201cInstall\u201d button at the bottom of the page to install the operating system onto your computer. When the installation is complete, unplug your USB flash drive and reboot. Upon rebooting, Arch Linux will be ready to use. Enjoy! Note To reboot on VirtualBox, remove the Optical ISO image we added in the \"Storage\" section of Settings.","title":"Installing Arch Linux with Calam Arch"},{"location":"p1/installm/#reference-video-links","text":"Installing Calam-Arch on VirtualBox","title":"Reference Video Links"},{"location":"p1/intro/","text":"Introduction Phase 1 guides you to basics of Arch Linux, meant for an absolute beginner to Linux. Contents Introduction To Arch Linux Installing Arch Linux Learning Basic Linux Learning how Packages Work Mastering Linux Filesystem","title":"Introduction"},{"location":"p1/intro/#introduction","text":"Phase 1 guides you to basics of Arch Linux, meant for an absolute beginner to Linux.","title":"Introduction"},{"location":"p1/intro/#contents","text":"Introduction To Arch Linux Installing Arch Linux Learning Basic Linux Learning how Packages Work Mastering Linux Filesystem","title":"Contents"},{"location":"p1/itoa/","text":"An Introduction to Arch Linux The great thing about Linux distros is that there\u2019s one for every skill level. If you\u2019re new to Linux and want something that works right out of the box (or rather, the ISO file), then either Ubuntu or Linux Mint is a good choice. On the other hand, if you\u2019re comfortable with Linux and Unix and you like to customize things a little (or perhaps, a lot), then you might want to give Arch Linux a try. Arch is a distro that\u2019s been around for about a decade, and tries to adhere to a \u201ckeep it simple stupid\u201d policy. Simplicity, however, means something different to the Arch community than it does to the Ubuntu user base. For Arch, \u201cunnecessary additions, modifications, or complications\u201d include a graphical user interface, wizards, or anything else intended to make it easy for Linux newbies to get their feet wet. Arch is targeted toward \u201ccompetent\u201d Linux users, people who are comfortable with the command line and editing configuration files.","title":"An Introduction to Arch Linux"},{"location":"p1/itoa/#an-introduction-to-arch-linux","text":"The great thing about Linux distros is that there\u2019s one for every skill level. If you\u2019re new to Linux and want something that works right out of the box (or rather, the ISO file), then either Ubuntu or Linux Mint is a good choice. On the other hand, if you\u2019re comfortable with Linux and Unix and you like to customize things a little (or perhaps, a lot), then you might want to give Arch Linux a try. Arch is a distro that\u2019s been around for about a decade, and tries to adhere to a \u201ckeep it simple stupid\u201d policy. Simplicity, however, means something different to the Arch community than it does to the Ubuntu user base. For Arch, \u201cunnecessary additions, modifications, or complications\u201d include a graphical user interface, wizards, or anything else intended to make it easy for Linux newbies to get their feet wet. Arch is targeted toward \u201ccompetent\u201d Linux users, people who are comfortable with the command line and editing configuration files.","title":"An Introduction to Arch Linux"},{"location":"p1/pkgmngsys/","text":"How To Manage Packages Using Pacman Pacman is a package manager for the arch Linux and arch-based Linux distributions. If you have used Debian-based OS like ubuntu, then the Pacman is similar to the apt command of Debian-based operating systems. Pacman contains the compressed files as a package format and maintains a text-based package database. Pacman keeps the system up to date by synchronizing package lists with the master server. Pacman can install the packages from the official repositories or your own build packages. It is the terminal way of installing software in Arch Linux, just like you install software in Windows/Mac In this section, I'll introduce you to some of the common pacman commands that you may need on a daily basis. How To Install Packages Using Pacman To install a package using pacman, you can use the following command syntax. For example, to install rust: # sudo pacman -S <package name> sudo pacman -S rust You can install multiple packages as follows: # sudo pacman -S <package name> <package name> sudo pacman -S rust golang You can also specify the repository you want to install the package from like this: # sudo pacman -S <package repository>/<package name> sudo pacman -S extra/rust In this command, the -S option means synchronize which is equivalent to install in the case of apt or dnf package managers. How To Remove Packages Using Pacman To remove a package using pacman you can use the following syntax: # sudo pacman -R <package name> sudo pacman -R rust This will remove the package but will leave the dependencies. You can remove the package with dependencies if they're not required by any other package by executing the following command: # sudo pacman -Rs <package name> sudo pacman -Rs rust Pacman often saves important configuration files when removing certain applications. You can override this behavior by using the following syntax: # sudo pacman -Rn <package name> sudo pacman -Rn rust I usually use sudo pacman -Rns whenever I want to uninstall something. One last thing that I want to show is how to remove orphan packages. In Ubuntu the sudo apt autoremove command uninstalls any unnecessary package. The equivalent command in Arch is: sudo pacman -Qdtq | pacman -Rs - This will cleanup any leftover package from previously installed packages. How To Upgrade Packages Using Pacman To upgrade all the packages in your system, you can use the following syntax: sudo pacman -Syu In this command, the S option synchronizes the packages, y refreshes the local package cache, and u updates the system. This is like the ultimate upgrade command and I run it at least once everyday. How To Search for Packages Using Pacman To search for a package in the database, you can use the following syntax: # sudo pacman -Ss <package name> sudo pacman -Ss rust This will print out all the packages found in the database with that search term and will also indicate if any of those are already installed. If you would like to check if a package is already installed or not, you can use the following command: # sudo pacman -Qs <package name> sudo pacman -Qs rust This is useful when you want to uninstall a package but do not know its exact name. How To Use AUR in Arch Linux According to It's FOSS , AUR stands for Arch User Repository. It is a community-driven repository for Arch-based Linux distributions users. It contains package descriptions named PKGBUILDs that allow you to compile a package from source with makepkg and then install it via pacman (package manager in Arch Linux). AUR is one of the most attractive features of Arch Linux. It's due to AUR that Arch Linux has a package count almost equal to Debian. You've already used pacman to install various packages. Sadly, you can not use that to install packages from AUR. You'll have to install one of the AUR helpers instead. Arch Linux doesn't support any of these helpers and advises you to learn how to build packages manually. I'll explain both techniques here. If you understand how a helper works, you'll be able to do it manually as well. How To Install Packages Using a Helper Among the available and currently maintained AUR helpers, I like the yay or yet another yogurt package. It's written in Go and is quite solid. You can not install yay like other packages. You'll have to get the source code and compile the program. You'll need git and the base-devel package to do so. Assuming you've already installed base-devel during Arch Linux installation: pacman -S git Clone the yay repository from GitHub and cd into it: git clone https://aur.archlinux.org/yay.git && cd yay To build and install yay from source, execute the following command: makepkg -si The makepkg script automates the build process of packages. The -si options stand for sync dependencies and install. The first option will install required dependencies (Golang in this case) and the later option will install the built package. After the build process finishes, makepkg will ask for installation confirmation and your password. Input your password carefully and let the installation finish. Check if yay has been installed properly or not: yay --version # yay v11.1.0 - libalpm v13.0.1 Now let's install something using yay. One of the common packages you may want to install is the visual-studio-code-bin package. To do so, execute the following command: yay -S visual-studio-code-bin Unlike pacman, you shouldn't run yay with sudo. Yay will look for the given package and will ask whether you would like to see the diff or not: All the repositories over at AUR comes with a PKGBUILD file which contains the instructions for building this package. Yay has this nice feature where it shows you what has changed in the PKGBUILD file since the last time. For now, I'll pick N for none and hit enter. Yay will now look for the dependencies and ask for your password to install them. Confirm the installation and provide your password. Yay will then install the dependencies and start building the package. Once built, yay will install the package and prompt for your password where necessary. After the installation finishes, search for Visual Studio Code in the application launcher: Congratulations on installing your first package from AUR. Yay commands are almost identical to pacman, so if you can do something with pacman, you should be able to do that with yay as well. In fact, yay can also install packages from official Arch Linux repositories like pacman. But I would suggest you to use yay only for installing packages from AUR when necessary and pacman for everything else. How To Install Packages Manually Like I said in the previous section, the ArchWiki suggests avoiding any AUR helper and installing packages from AUR manually. I'll now show you how to do it. Make sure you have git and base-devel packages installed. If not, use pacman to install them. For the demonstration, let's install Spotify this time. First visit the AUR page for the spotify package - https://aur.archlinux.org/packages/spotify/ and copy the \"Git Clone URL\" from there. The page even lists all the dependencies you'll need. Clone the repository to your machine: Every AUR repository comes with a PKGBUILD file containing the instructions for building the package. Whenever you're installing a package from AUR, it's a great idea to checkout the PKGBUILD file using something like the cat command: Make sure there's nothing harmful in the file. Once you're satisfied, use makepkg to install any dependencies, build the package, and install it. Ideally there shouldn't be any issues but sometimes, things can take an unexpected turn. In these cases, go back to the corresponding AUR page and check the user comments. Like in this case, I found the following pinned comment: Turns out the package requires you to add the Spotify for Linux gpg key to the user kyechain. This command downloads the gpg key using curl and pipes it as the input of the gpg --import command: Try executing makepkg -si once again and everything should work fine this time: See, told ya! Manually installing packages often involves such troubleshooting but help is almost always around the comment corner. Let's enjoy some music now.","title":"How To Manage Packages Using Pacman"},{"location":"p1/pkgmngsys/#how-to-manage-packages-using-pacman","text":"Pacman is a package manager for the arch Linux and arch-based Linux distributions. If you have used Debian-based OS like ubuntu, then the Pacman is similar to the apt command of Debian-based operating systems. Pacman contains the compressed files as a package format and maintains a text-based package database. Pacman keeps the system up to date by synchronizing package lists with the master server. Pacman can install the packages from the official repositories or your own build packages. It is the terminal way of installing software in Arch Linux, just like you install software in Windows/Mac In this section, I'll introduce you to some of the common pacman commands that you may need on a daily basis.","title":"How To Manage Packages Using Pacman"},{"location":"p1/pkgmngsys/#how-to-install-packages-using-pacman","text":"To install a package using pacman, you can use the following command syntax. For example, to install rust: # sudo pacman -S <package name> sudo pacman -S rust You can install multiple packages as follows: # sudo pacman -S <package name> <package name> sudo pacman -S rust golang You can also specify the repository you want to install the package from like this: # sudo pacman -S <package repository>/<package name> sudo pacman -S extra/rust In this command, the -S option means synchronize which is equivalent to install in the case of apt or dnf package managers.","title":"How To Install Packages Using Pacman"},{"location":"p1/pkgmngsys/#how-to-remove-packages-using-pacman","text":"To remove a package using pacman you can use the following syntax: # sudo pacman -R <package name> sudo pacman -R rust This will remove the package but will leave the dependencies. You can remove the package with dependencies if they're not required by any other package by executing the following command: # sudo pacman -Rs <package name> sudo pacman -Rs rust Pacman often saves important configuration files when removing certain applications. You can override this behavior by using the following syntax: # sudo pacman -Rn <package name> sudo pacman -Rn rust I usually use sudo pacman -Rns whenever I want to uninstall something. One last thing that I want to show is how to remove orphan packages. In Ubuntu the sudo apt autoremove command uninstalls any unnecessary package. The equivalent command in Arch is: sudo pacman -Qdtq | pacman -Rs - This will cleanup any leftover package from previously installed packages.","title":"How To Remove Packages Using Pacman"},{"location":"p1/pkgmngsys/#how-to-upgrade-packages-using-pacman","text":"To upgrade all the packages in your system, you can use the following syntax: sudo pacman -Syu In this command, the S option synchronizes the packages, y refreshes the local package cache, and u updates the system. This is like the ultimate upgrade command and I run it at least once everyday.","title":"How To Upgrade Packages Using Pacman"},{"location":"p1/pkgmngsys/#how-to-search-for-packages-using-pacman","text":"To search for a package in the database, you can use the following syntax: # sudo pacman -Ss <package name> sudo pacman -Ss rust This will print out all the packages found in the database with that search term and will also indicate if any of those are already installed. If you would like to check if a package is already installed or not, you can use the following command: # sudo pacman -Qs <package name> sudo pacman -Qs rust This is useful when you want to uninstall a package but do not know its exact name.","title":"How To Search for Packages Using Pacman"},{"location":"p1/pkgmngsys/#how-to-use-aur-in-arch-linux","text":"According to It's FOSS , AUR stands for Arch User Repository. It is a community-driven repository for Arch-based Linux distributions users. It contains package descriptions named PKGBUILDs that allow you to compile a package from source with makepkg and then install it via pacman (package manager in Arch Linux). AUR is one of the most attractive features of Arch Linux. It's due to AUR that Arch Linux has a package count almost equal to Debian. You've already used pacman to install various packages. Sadly, you can not use that to install packages from AUR. You'll have to install one of the AUR helpers instead. Arch Linux doesn't support any of these helpers and advises you to learn how to build packages manually. I'll explain both techniques here. If you understand how a helper works, you'll be able to do it manually as well.","title":"How To Use AUR in Arch Linux"},{"location":"p1/pkgmngsys/#how-to-install-packages-using-a-helper","text":"Among the available and currently maintained AUR helpers, I like the yay or yet another yogurt package. It's written in Go and is quite solid. You can not install yay like other packages. You'll have to get the source code and compile the program. You'll need git and the base-devel package to do so. Assuming you've already installed base-devel during Arch Linux installation: pacman -S git Clone the yay repository from GitHub and cd into it: git clone https://aur.archlinux.org/yay.git && cd yay To build and install yay from source, execute the following command: makepkg -si The makepkg script automates the build process of packages. The -si options stand for sync dependencies and install. The first option will install required dependencies (Golang in this case) and the later option will install the built package. After the build process finishes, makepkg will ask for installation confirmation and your password. Input your password carefully and let the installation finish. Check if yay has been installed properly or not: yay --version # yay v11.1.0 - libalpm v13.0.1 Now let's install something using yay. One of the common packages you may want to install is the visual-studio-code-bin package. To do so, execute the following command: yay -S visual-studio-code-bin Unlike pacman, you shouldn't run yay with sudo. Yay will look for the given package and will ask whether you would like to see the diff or not: All the repositories over at AUR comes with a PKGBUILD file which contains the instructions for building this package. Yay has this nice feature where it shows you what has changed in the PKGBUILD file since the last time. For now, I'll pick N for none and hit enter. Yay will now look for the dependencies and ask for your password to install them. Confirm the installation and provide your password. Yay will then install the dependencies and start building the package. Once built, yay will install the package and prompt for your password where necessary. After the installation finishes, search for Visual Studio Code in the application launcher: Congratulations on installing your first package from AUR. Yay commands are almost identical to pacman, so if you can do something with pacman, you should be able to do that with yay as well. In fact, yay can also install packages from official Arch Linux repositories like pacman. But I would suggest you to use yay only for installing packages from AUR when necessary and pacman for everything else.","title":"How To Install Packages Using a Helper"},{"location":"p1/pkgmngsys/#how-to-install-packages-manually","text":"Like I said in the previous section, the ArchWiki suggests avoiding any AUR helper and installing packages from AUR manually. I'll now show you how to do it. Make sure you have git and base-devel packages installed. If not, use pacman to install them. For the demonstration, let's install Spotify this time. First visit the AUR page for the spotify package - https://aur.archlinux.org/packages/spotify/ and copy the \"Git Clone URL\" from there. The page even lists all the dependencies you'll need. Clone the repository to your machine: Every AUR repository comes with a PKGBUILD file containing the instructions for building the package. Whenever you're installing a package from AUR, it's a great idea to checkout the PKGBUILD file using something like the cat command: Make sure there's nothing harmful in the file. Once you're satisfied, use makepkg to install any dependencies, build the package, and install it. Ideally there shouldn't be any issues but sometimes, things can take an unexpected turn. In these cases, go back to the corresponding AUR page and check the user comments. Like in this case, I found the following pinned comment: Turns out the package requires you to add the Spotify for Linux gpg key to the user kyechain. This command downloads the gpg key using curl and pipes it as the input of the gpg --import command: Try executing makepkg -si once again and everything should work fine this time: See, told ya! Manually installing packages often involves such troubleshooting but help is almost always around the comment corner. Let's enjoy some music now.","title":"How To Install Packages Manually"},{"location":"p1/repos/","text":"Understanding Linux What is Linux? Linux powers a variety of computer systems from light bulbs to guns, laptops to large computer centers. Linux powers everything from your phone to your smart refrigerator. In desktop computing, Linux provides an alternative to commercial operating systems such as Windows and macOS. Linux sources from some of the earliest computer operating systems from the 1960s and 1970s, and so it retains its root philosophies of strong user-level security, customization, and system stability. What is a Linux Distribution? On its own Linux isn't really all that useful. You need to add other programs and tools to it in order to make it what you want it to be. For instance, a Linux powered fridge wouldn't work with just Linux itself. Somebody needs to write the programs and device drivers required to control the thermostat, output a display showing the temperature, and every other feature which is considered to make the fridge smart . Linux distributions are at their very core the Linux kernel, with the GNU tools added on top and then a set of other applications that the developers decided to package together to make their distribution. A desktop Linux distribution is generally built up with some or all of the following tools: The Linux kernel GNU/Tools A display manager A window manager A desktop environment An installer Package managers Desktop software such as office suites, email clients, web browsers, video players, audio players, etc What Is a Desktop Environment? A typical Linux distribution includes several different components. A display manager logs you in while a window manager governs windows, panel, menus, dash interfaces and core applications. Many of these items are bundled together to make a desktop environment. Some Linux distributions ship with just one desktop environment (although others are available in the software repositories), while others offer different versions of the distribution fine-tuned for different desktop environments. Common desktop environments include Cinnamon, GNOME, Unity, KDE, Enlightenment, XFCE, LXDE and MATE. Cinnamon is a more conventional desktop environment that looks much like Windows 7, with a panel at the bottom, a menu, system tray icons, and quick launch icons. GNOME and Unity are fairly similar. They are modern desktop environments that use the concept of launcher icons and a dashboard-style display for picking applications. There are also core applications that integrate well with the overall theme of the desktop environment. KDE is a classic-style desktop environment with many custom features and a core set of applications that are all highly customizable. Enlightenment, XFCE, LXDE, and MATE are lightweight desktop environments with panels and menus. Are There Any Decent Office Suites for Linux? For personal use and for small- to medium-sized businesses, LibreOffice presents a strong alternative to Microsoft Office, for free. LibreOffice comes with a word processor with the majority of the features you expect from a word processor. It also features a decent spreadsheet tool that is full-featured and includes a basic programming engine, although it isn't compatible with Excel VBA. Other tools include the presentation, maths, database, and drawing packages which are all good. To install libreoffice on Arch sudo pacman -S libreoffice-fresh # This is the latest version with latest features sudo pacman -S libreoffice-still # This is the stable edition with least breakage possibilities The Linux Command Line Given its long heritage and the diversity of approach of modern desktop environments, a lot of Linux still works from a shell session. In the macOS world, these sessions are called the terminal; in Windows, the Command Prompt. Although the graphical user interface of modern Linux DEs can do just about everything, much online education about Linux relies on the shell because it's not tied to the peculiarities of a given distribution or window manager. People new to Linux can get away with rarely or never working from the shell, but people who grow to love Linux often go to the shell first because of how easy it is to type one command instead of clicking through many different menus. A terminal always comes with a desktop environment. You can just search up \"Terminal\" in your System and pick any terminal emulator. Packages A package delivers and maintains new software for Linux-based computers. Just as Windows-based computers rely on executable installers, the Linux ecosystem depends on packages that are administered through software repositories. These files govern the addition, maintenance, and removal of programs on the computer. Because each Linux computer uses different software, including different kernels, developers cannot guarantee that a \"Linux program\" will run correctly on any given computer. To fix this interoperability problem, packages include a manifest of dependencies, or lists of programs and versions that must be satisfied for the packaged software to run correctly on a given computer. Software Repository A software repository is a storage location from which software packages are retrieved for installation. Arch Linux official repositories contain essential and popular software, readily accessible via pacman. They are maintained by package maintainers. Packages in the official repositories are constantly upgraded: when a package is upgraded, its old version is removed from the repository. There are no major Arch releases: each package is upgraded as new versions become available from upstream sources. Each repository is always coherent, i.e. the packages that it hosts always have reciprocally compatible versions. A package manager does nothing but grab packages from an online software repository and embed it to your system. Stable repositories core This repository can be found in .../core/os/ on your favorite mirror . core contains packages for: booting Arch Linux connecting to the Internet building packages management and repair of supported file systems the system setup process (e.g. openssh ) as well as dependencies of the above (not necessarily makedepends ) and the base meta package . core has fairly strict quality requirements. Developers/users need to signoff on updates before package updates are accepted. For packages with low usage, a reasonable exposure is enough: informing people about update, requesting signoffs, keeping in testing up to a week depending on the severity of the change, lack of outstanding bug reports, along with the implicit signoff of the package maintainer. Tip: To create a local repository with packages from core (or other repositories) without an internet connection see Pacman tips#Installing packages from a CD/DVD or USB stick extra This repository can be found in .../extra/os/ on your favorite mirror. extra contains all packages that do not fit in core . Example: Xorg, window managers, web browsers, media players, tools for working with languages such as Python and Ruby, and a lot more. community This repository can be found in .../community/os/ on your favorite mirror. community contains packages that have been adopted by Trusted Users from the Arch User Repository . Some of these packages may eventually make the transition to the core or extra repositories as the developers consider them crucial to the distribution. multilib This repository can be found in .../multilib/os/ on your favorite mirror. multilib contains 32-bit software and libraries that can be used to run and build 32-bit applications on 64-bit installs (e.g. wine , steam , etc). With the multilib repository enabled, the 32-bit compatible libraries are located under /usr/lib32/ . Enabling multilib To enable multilib repository, uncomment the [multilib] section in /etc/pacman.conf : /etc/pacman.conf [multilib] Include = /etc/pacman.d/mirrorlist Then upgrade the system and install the desired multilib packages. Tip: Run pacman -Sl multilib to list all packages in the multilib repository. 32-bit library package names begin with lib32- . Disabling multilib Execute the following command to remove all packages that were installed from multilib : pacman -R $(comm -12 <(pacman -Qq | sort) <(pacman -Slq multilib | sort)) If you have conflicts with gcc-libs reinstall the gcc-libs package and the base-devel group. Comment out the [multilib] section in /etc/pacman.conf : /etc/pacman.conf [multilib] #Include = /etc/pacman.d/mirrorlist Then upgrade the system. Now you know how to use Linux as a standard user it is time to learn something a little bit more advanced such as learning how to use the command line. Becoming proficient with the command line takes time but you can get to grips with the basics very quickly indeed. At the very least you need to know how to navigate the file system which includes working out your present working directory, changing directories, making new directories, finding files, deleting files and creating new files. No one can be a master Linux in a day. You don't become an expert on any subject overnight. Continual use and continual learning is the only way to get to grips with anything whether it is learning to become a Linux guru or learning how to play the bagpipes. Following online courses, keeping up to date with Linux news and getting help from the Linux community is the best way to move forward and remember the Linux man command is your friend. Other resources to learn ArchWiki","title":"Understanding Linux"},{"location":"p1/repos/#understanding-linux","text":"","title":"Understanding Linux"},{"location":"p1/repos/#what-is-linux","text":"Linux powers a variety of computer systems from light bulbs to guns, laptops to large computer centers. Linux powers everything from your phone to your smart refrigerator. In desktop computing, Linux provides an alternative to commercial operating systems such as Windows and macOS. Linux sources from some of the earliest computer operating systems from the 1960s and 1970s, and so it retains its root philosophies of strong user-level security, customization, and system stability.","title":"What is Linux?"},{"location":"p1/repos/#what-is-a-linux-distribution","text":"On its own Linux isn't really all that useful. You need to add other programs and tools to it in order to make it what you want it to be. For instance, a Linux powered fridge wouldn't work with just Linux itself. Somebody needs to write the programs and device drivers required to control the thermostat, output a display showing the temperature, and every other feature which is considered to make the fridge smart . Linux distributions are at their very core the Linux kernel, with the GNU tools added on top and then a set of other applications that the developers decided to package together to make their distribution. A desktop Linux distribution is generally built up with some or all of the following tools: The Linux kernel GNU/Tools A display manager A window manager A desktop environment An installer Package managers Desktop software such as office suites, email clients, web browsers, video players, audio players, etc","title":"What is a Linux Distribution?"},{"location":"p1/repos/#what-is-a-desktop-environment","text":"A typical Linux distribution includes several different components. A display manager logs you in while a window manager governs windows, panel, menus, dash interfaces and core applications. Many of these items are bundled together to make a desktop environment. Some Linux distributions ship with just one desktop environment (although others are available in the software repositories), while others offer different versions of the distribution fine-tuned for different desktop environments. Common desktop environments include Cinnamon, GNOME, Unity, KDE, Enlightenment, XFCE, LXDE and MATE. Cinnamon is a more conventional desktop environment that looks much like Windows 7, with a panel at the bottom, a menu, system tray icons, and quick launch icons. GNOME and Unity are fairly similar. They are modern desktop environments that use the concept of launcher icons and a dashboard-style display for picking applications. There are also core applications that integrate well with the overall theme of the desktop environment. KDE is a classic-style desktop environment with many custom features and a core set of applications that are all highly customizable. Enlightenment, XFCE, LXDE, and MATE are lightweight desktop environments with panels and menus.","title":"What Is a Desktop Environment?"},{"location":"p1/repos/#are-there-any-decent-office-suites-for-linux","text":"For personal use and for small- to medium-sized businesses, LibreOffice presents a strong alternative to Microsoft Office, for free. LibreOffice comes with a word processor with the majority of the features you expect from a word processor. It also features a decent spreadsheet tool that is full-featured and includes a basic programming engine, although it isn't compatible with Excel VBA. Other tools include the presentation, maths, database, and drawing packages which are all good. To install libreoffice on Arch sudo pacman -S libreoffice-fresh # This is the latest version with latest features sudo pacman -S libreoffice-still # This is the stable edition with least breakage possibilities","title":"Are There Any Decent Office Suites for Linux?"},{"location":"p1/repos/#the-linux-command-line","text":"Given its long heritage and the diversity of approach of modern desktop environments, a lot of Linux still works from a shell session. In the macOS world, these sessions are called the terminal; in Windows, the Command Prompt. Although the graphical user interface of modern Linux DEs can do just about everything, much online education about Linux relies on the shell because it's not tied to the peculiarities of a given distribution or window manager. People new to Linux can get away with rarely or never working from the shell, but people who grow to love Linux often go to the shell first because of how easy it is to type one command instead of clicking through many different menus. A terminal always comes with a desktop environment. You can just search up \"Terminal\" in your System and pick any terminal emulator.","title":"The Linux Command Line"},{"location":"p1/repos/#packages","text":"A package delivers and maintains new software for Linux-based computers. Just as Windows-based computers rely on executable installers, the Linux ecosystem depends on packages that are administered through software repositories. These files govern the addition, maintenance, and removal of programs on the computer. Because each Linux computer uses different software, including different kernels, developers cannot guarantee that a \"Linux program\" will run correctly on any given computer. To fix this interoperability problem, packages include a manifest of dependencies, or lists of programs and versions that must be satisfied for the packaged software to run correctly on a given computer.","title":"Packages"},{"location":"p1/repos/#software-repository","text":"A software repository is a storage location from which software packages are retrieved for installation. Arch Linux official repositories contain essential and popular software, readily accessible via pacman. They are maintained by package maintainers. Packages in the official repositories are constantly upgraded: when a package is upgraded, its old version is removed from the repository. There are no major Arch releases: each package is upgraded as new versions become available from upstream sources. Each repository is always coherent, i.e. the packages that it hosts always have reciprocally compatible versions. A package manager does nothing but grab packages from an online software repository and embed it to your system.","title":"Software Repository"},{"location":"p1/repos/#stable-repositories","text":"","title":"Stable repositories"},{"location":"p1/repos/#core","text":"This repository can be found in .../core/os/ on your favorite mirror . core contains packages for: booting Arch Linux connecting to the Internet building packages management and repair of supported file systems the system setup process (e.g. openssh ) as well as dependencies of the above (not necessarily makedepends ) and the base meta package . core has fairly strict quality requirements. Developers/users need to signoff on updates before package updates are accepted. For packages with low usage, a reasonable exposure is enough: informing people about update, requesting signoffs, keeping in testing up to a week depending on the severity of the change, lack of outstanding bug reports, along with the implicit signoff of the package maintainer. Tip: To create a local repository with packages from core (or other repositories) without an internet connection see Pacman tips#Installing packages from a CD/DVD or USB stick","title":"core"},{"location":"p1/repos/#extra","text":"This repository can be found in .../extra/os/ on your favorite mirror. extra contains all packages that do not fit in core . Example: Xorg, window managers, web browsers, media players, tools for working with languages such as Python and Ruby, and a lot more.","title":"extra"},{"location":"p1/repos/#community","text":"This repository can be found in .../community/os/ on your favorite mirror. community contains packages that have been adopted by Trusted Users from the Arch User Repository . Some of these packages may eventually make the transition to the core or extra repositories as the developers consider them crucial to the distribution.","title":"community"},{"location":"p1/repos/#multilib","text":"This repository can be found in .../multilib/os/ on your favorite mirror. multilib contains 32-bit software and libraries that can be used to run and build 32-bit applications on 64-bit installs (e.g. wine , steam , etc). With the multilib repository enabled, the 32-bit compatible libraries are located under /usr/lib32/ .","title":"multilib"},{"location":"p1/repos/#enabling-multilib","text":"To enable multilib repository, uncomment the [multilib] section in /etc/pacman.conf : /etc/pacman.conf [multilib] Include = /etc/pacman.d/mirrorlist Then upgrade the system and install the desired multilib packages. Tip: Run pacman -Sl multilib to list all packages in the multilib repository. 32-bit library package names begin with lib32- .","title":"Enabling multilib"},{"location":"p1/repos/#disabling-multilib","text":"Execute the following command to remove all packages that were installed from multilib : pacman -R $(comm -12 <(pacman -Qq | sort) <(pacman -Slq multilib | sort)) If you have conflicts with gcc-libs reinstall the gcc-libs package and the base-devel group. Comment out the [multilib] section in /etc/pacman.conf : /etc/pacman.conf [multilib] #Include = /etc/pacman.d/mirrorlist Then upgrade the system. Now you know how to use Linux as a standard user it is time to learn something a little bit more advanced such as learning how to use the command line. Becoming proficient with the command line takes time but you can get to grips with the basics very quickly indeed. At the very least you need to know how to navigate the file system which includes working out your present working directory, changing directories, making new directories, finding files, deleting files and creating new files. No one can be a master Linux in a day. You don't become an expert on any subject overnight. Continual use and continual learning is the only way to get to grips with anything whether it is learning to become a Linux guru or learning how to play the bagpipes. Following online courses, keeping up to date with Linux news and getting help from the Linux community is the best way to move forward and remember the Linux man command is your friend.","title":"Disabling multilib"},{"location":"p1/repos/#other-resources-to-learn","text":"ArchWiki","title":"Other resources to learn"},{"location":"p2/0-getting-the-base-project-ready/","text":"Git and Github First we need to plan our bases for hosting source code and project management. I use and prefer Github for all my project management. Git and GitHub are two technologies that every developer should learn, irrespective of their field. If you're a beginner developer, you might think that these two terms mean the same thing \u2013 but they're different. This tutorial will help you understand what Git and version control are, the basic Git commands you need to know, how you can use its features to boost your work efficiency, and how to extend these features using GitHub. This guide is beginner friendly, as the examples will be very easy to understand. It will also be a generalized tutorial so anyone can follow along no matter what your favorite programming language is. For our project, we'll make a to-do list written in a text (txt) file. You will see how we can use the features of Git to work on and create a final version of the list. Prerequisites In order to complete this tutorial, you'll need the following: A command line interface. A text editor of your choice (I will be using VS Code). A GitHub account. What is Git? Git is a version control system which lets you track changes you make to your files over time. With Git, you can revert to various states of your files (like a time traveling machine). You can also make a copy of your file, make changes to that copy, and then merge these changes to the original copy. For example, you could be working on a website's landing page and discover that you do not like the navigation bar. But at the same time, you might not want to start altering its components because it might get worse. With Git, you can create an identical copy of that file and play around with the navigation bar. Then, when you are satisfied with your changes, you can merge the copy to the original file. You are not limited to using Git just for source code files \u2013 you can also use it to keep track of text files or even images. This means that Git is not just for developers \u2013 anyone can find it helpful. How to install Git In order to use Git, you have to install it on your computer. To do this, you can download the latest version on the official website . You can download for your operating system from the options given. You can also install Git using the command line, but since the commands vary with each operating system, we'll focus on the more general approach. How to configure Git I will assume that at this point you have installed Git. To verify this, you can run this command on the command line: git --version . This shows you the current version installed on you PC. The next thing you'll need to do is to set your username and email address. Git will use this information to identify who made specific changes to files. To set your username, type and execute these commands: git config --global user.name \"YOUR_USERNAME\" and git config --global user.email \"YOUR_EMAIL\" . Just make sure to replace \"YOUR_USERNAME\" and \"YOUR_EMAIL\" with the values you choose. How to Create and Initialize a Project in Git We are finally done with installing and setting up Git. It is now time to create our project. I have created a folder on my desktop called Git and GitHub tutorial . Using the command line, navigate to your new project's location. For me, I would run the following commands: cd desktop cd Git and GitHub tutorial If you are new to the command line and are still learning how to use it to navigate around your PC, then I would suggest using Microsoft's Visual Studio Code. It is a code editor which has an inbuilt terminal for executing commands. You can download it here . After installing VS Code, open your project in the editor and open a new terminal for your project. This automatically points the terminal/command line to your project's path. Now to initialize your project, simply run git init . This will tell Git to get ready to start watching your files for every change that occurs. It looks like this: The first line has information about my PC and the path to where the folder exists. The second line is the command git init , and the third line is the response sent back telling me that my repository (repo) has been initialized. It is considered empty because we have not told Git what files to track. A repository is just another way to define a project being watched/tracked by Git. Git project files I have created only one file called todo.txt . This is what the file looks like: MY TO-DO LIST 1. Write an article. 2. Code. 3. Study books. 4. Attend classes on time. 5. Visit aunt. 6. Apply for remote jobs. Before we proceed with learning other Git commands, let's talk about GitHub. What is GitHub? GitHub is an online hosting service for Git repositories. Imagine working on a project at home and while you are away, maybe at a friend's place, you suddenly remember the solution to a code error that has kept you restless for days. You cannot make these changes because your PC is not with you. But if you have your project hosted on GitHub, you can access and download that project with a command on whatever computer you have access to. Then you can make your changes and push the latest version back to GitHub. In summary, GitHub lets you store your repo on their platform. Another awesome feature that comes with GitHub is the ability to collaborate with other developers from any location. Now that we have created and initialized our project locally, let's push it to GitHub. If you are a beginner, you will come across some new terms like push, commit, add, and so on \u2013 but do not be overwhelmed by them. With some practice you will be able to remember these terms and what they do. How to push a repository to GitHub I will divide this section into steps to help you understand the process more clearly. Step 1 \u2013 Create a GitHub account To be able to use GitHub, you will have to create an account first. You can do that on their website . Step 2 \u2013 Create a repository You can click on the + symbol on the top right corner of the page then choose \"New repository\". Give your repo a name then scroll down and click on \"Create repository\". Step 3 \u2013 Add and commit file(s) Before we \"add\" and \"commit\" our files, you need to understand the stages of a file being tracked by Git. Committed state A file is in the committed state when all the changes made to the file have been saved in the local repo. Files in the committed stage are files ready to be pushed to the remote repo (on GitHub). Modified state A file in the modified state has some changes made to it but it's not yet saved. This means that the state of the file has been altered from its previous state in the committed state. Staged state A file in the staged state means it is ready to be committed. In this state, all necessary changes have been made so the next step is to move the file to the commit state. You can understand this better by imagining Git as a camera. The camera will only take a snapshot when the file reaches the commit state. After this state, the camera starts comparing changes being made to the same file with the last snapshot (this is the modified state). And when the required changes have been made, the file is staged and moved to the commit state for a new snapshot. This might be a lot of information to take in at the moment, but do not be discouraged \u2013 it gets easier with practice. How to add files in Git When we first initialized our project, the file was not being tracked by Git. To do that, we use this command git add . The period or dot that comes after add means all the files that exist in the repository. If you want to add a specific file, maybe one named about.txt , you use git add about.txt . Now our file is in the staged state. You will not get a response after this command, but to know what state your file is in, you can run the git status command. How to commit files in Git The next state for a file after the staged state is the committed state. To commit our file, we use the git commit -m \"first commit\" command. The first part of the command git commit tells Git that all the files staged are ready to be committed so it is time to take a snapshot. The second part -m \"first commit\" is the commit message. -m is shorthand for message while the text inside the parenthesis is the commit message. After executing this command, you should get a response similar to this: Now our file is in the committed state. Step 4 \u2013 Push the repository to GitHub After you create the repo, you should be redirected to a page that tells you how to create a repo locally or push an existing one. In our case, the project already exists locally so we will use commands in the \"\u2026or push an existing repository from the command line\" section. These are the commands: git remote add origin https://github.com/ihechikara/git-and-github-tutorial.git git branch -M main git push -u origin main The first command git remote add origin https://github.com/ihechikara/git-and-github-tutorial.git creates a connection between your local repo and the remote repo on Github. The URL for your remote project should be entirely different from the one above. So to follow along, make sure you are following the steps and working with your own remote repo. You won't usually get a response after executing this command but make sure you have an internet connection. The second command git branch -M main changes your main branch's name to \"main\". The default branch might be created as \"master\", but \"main\" is the standard name for this repo now. There is usually no response here. The last command git push -u origin main pushes your repo from your local device to GitHub. You should get a response similar to this: To help you deepen your understanding of file stages, I will make changes to the file and then push the new version to GitHub. Recall that our file is now in the committed state. Let's make changes to the file and take note of the states. I am going to add a new task to the to-do list: MY TO-DO LIST 1. Write an article. 2. Code. 3. Study books. 4. Attend classes on time. 5. Visit aunt. 6. Apply for remote jobs. 7. Practice code After adding the new task, run the git status command. This is what you should see: After making changes to the file, it moved to the modified state \u2013 but it's not yet staged for commit, so you can't push it to GitHub yet. Git has not taken a final snapshot of this current state as it's only comparing the changes we have made now with the last snapshot. Now we are going to add (stage) this file and then commit and push it. This is the same as in the last section. We first add the file by using git add . which adds all the files in the folder (one file in our case). Then we commit the file by running git commit -m \"added new task\" followed by git push -u origin main . Those are the three steps to pushing your modified files to GitHub. You add, commit, and then push. I hope you now understand file stages and the commands associated with them. How to Pull a Repository in Git To pull in Git means to clone a remote repository's current state into your computer/repository. This comes in handy when you want to work on your repo from a different computer or when you are contributing to an open source project online. To test this, don't worry about switching to a new computer. Just run cd .. to leave the current directory and go back one step. In my own case, I have navigated back to my desktop. Go to GitHub, and on your repository's main page you should see a green button that says \"Code\". When you click on the button, you should see some options in a dropdown menu. Go on and copy the HTTPS URL. After that, run git clone YOUR_HTTPS_URL . This command pulls the remote repository into your local computer in a folder called git-and-git-tutorial. That is: Conclusion This article covered the basic commands that'll help get you started using Git. We also started learning how to use GitHub. If you have followed up to this point then congratulations, you are good to go. You can now use Git in your projects no matter what programming language you are using. You should know that these are not all the commands that exist in Git \u2013 so feel free to do more research to learn more commands and their uses. This article and this cheat sheet are great places to start. This is a great place to see a detailed list of more Git commands.","title":"Git and Github"},{"location":"p2/0-getting-the-base-project-ready/#git-and-github","text":"First we need to plan our bases for hosting source code and project management. I use and prefer Github for all my project management. Git and GitHub are two technologies that every developer should learn, irrespective of their field. If you're a beginner developer, you might think that these two terms mean the same thing \u2013 but they're different. This tutorial will help you understand what Git and version control are, the basic Git commands you need to know, how you can use its features to boost your work efficiency, and how to extend these features using GitHub. This guide is beginner friendly, as the examples will be very easy to understand. It will also be a generalized tutorial so anyone can follow along no matter what your favorite programming language is. For our project, we'll make a to-do list written in a text (txt) file. You will see how we can use the features of Git to work on and create a final version of the list.","title":"Git and Github"},{"location":"p2/0-getting-the-base-project-ready/#prerequisites","text":"In order to complete this tutorial, you'll need the following: A command line interface. A text editor of your choice (I will be using VS Code). A GitHub account.","title":"Prerequisites"},{"location":"p2/0-getting-the-base-project-ready/#what-is-git","text":"Git is a version control system which lets you track changes you make to your files over time. With Git, you can revert to various states of your files (like a time traveling machine). You can also make a copy of your file, make changes to that copy, and then merge these changes to the original copy. For example, you could be working on a website's landing page and discover that you do not like the navigation bar. But at the same time, you might not want to start altering its components because it might get worse. With Git, you can create an identical copy of that file and play around with the navigation bar. Then, when you are satisfied with your changes, you can merge the copy to the original file. You are not limited to using Git just for source code files \u2013 you can also use it to keep track of text files or even images. This means that Git is not just for developers \u2013 anyone can find it helpful.","title":"What is Git?"},{"location":"p2/0-getting-the-base-project-ready/#how-to-install-git","text":"In order to use Git, you have to install it on your computer. To do this, you can download the latest version on the official website . You can download for your operating system from the options given. You can also install Git using the command line, but since the commands vary with each operating system, we'll focus on the more general approach.","title":"How to install Git"},{"location":"p2/0-getting-the-base-project-ready/#how-to-configure-git","text":"I will assume that at this point you have installed Git. To verify this, you can run this command on the command line: git --version . This shows you the current version installed on you PC. The next thing you'll need to do is to set your username and email address. Git will use this information to identify who made specific changes to files. To set your username, type and execute these commands: git config --global user.name \"YOUR_USERNAME\" and git config --global user.email \"YOUR_EMAIL\" . Just make sure to replace \"YOUR_USERNAME\" and \"YOUR_EMAIL\" with the values you choose.","title":"How to configure Git"},{"location":"p2/0-getting-the-base-project-ready/#how-to-create-and-initialize-a-project-in-git","text":"We are finally done with installing and setting up Git. It is now time to create our project. I have created a folder on my desktop called Git and GitHub tutorial . Using the command line, navigate to your new project's location. For me, I would run the following commands: cd desktop cd Git and GitHub tutorial If you are new to the command line and are still learning how to use it to navigate around your PC, then I would suggest using Microsoft's Visual Studio Code. It is a code editor which has an inbuilt terminal for executing commands. You can download it here . After installing VS Code, open your project in the editor and open a new terminal for your project. This automatically points the terminal/command line to your project's path. Now to initialize your project, simply run git init . This will tell Git to get ready to start watching your files for every change that occurs. It looks like this: The first line has information about my PC and the path to where the folder exists. The second line is the command git init , and the third line is the response sent back telling me that my repository (repo) has been initialized. It is considered empty because we have not told Git what files to track. A repository is just another way to define a project being watched/tracked by Git.","title":"How to Create and Initialize a Project in Git"},{"location":"p2/0-getting-the-base-project-ready/#git-project-files","text":"I have created only one file called todo.txt . This is what the file looks like: MY TO-DO LIST 1. Write an article. 2. Code. 3. Study books. 4. Attend classes on time. 5. Visit aunt. 6. Apply for remote jobs. Before we proceed with learning other Git commands, let's talk about GitHub.","title":"Git project files"},{"location":"p2/0-getting-the-base-project-ready/#what-is-github","text":"GitHub is an online hosting service for Git repositories. Imagine working on a project at home and while you are away, maybe at a friend's place, you suddenly remember the solution to a code error that has kept you restless for days. You cannot make these changes because your PC is not with you. But if you have your project hosted on GitHub, you can access and download that project with a command on whatever computer you have access to. Then you can make your changes and push the latest version back to GitHub. In summary, GitHub lets you store your repo on their platform. Another awesome feature that comes with GitHub is the ability to collaborate with other developers from any location. Now that we have created and initialized our project locally, let's push it to GitHub. If you are a beginner, you will come across some new terms like push, commit, add, and so on \u2013 but do not be overwhelmed by them. With some practice you will be able to remember these terms and what they do.","title":"What is GitHub?"},{"location":"p2/0-getting-the-base-project-ready/#how-to-push-a-repository-to-github","text":"I will divide this section into steps to help you understand the process more clearly.","title":"How to push a repository to GitHub"},{"location":"p2/0-getting-the-base-project-ready/#step-1-create-a-github-account","text":"To be able to use GitHub, you will have to create an account first. You can do that on their website .","title":"Step 1 \u2013 Create a GitHub account"},{"location":"p2/0-getting-the-base-project-ready/#step-2-create-a-repository","text":"You can click on the + symbol on the top right corner of the page then choose \"New repository\". Give your repo a name then scroll down and click on \"Create repository\".","title":"Step 2 \u2013 Create a repository"},{"location":"p2/0-getting-the-base-project-ready/#step-3-add-and-commit-files","text":"Before we \"add\" and \"commit\" our files, you need to understand the stages of a file being tracked by Git.","title":"Step 3 \u2013 Add and commit file(s)"},{"location":"p2/0-getting-the-base-project-ready/#committed-state","text":"A file is in the committed state when all the changes made to the file have been saved in the local repo. Files in the committed stage are files ready to be pushed to the remote repo (on GitHub).","title":"Committed state"},{"location":"p2/0-getting-the-base-project-ready/#modified-state","text":"A file in the modified state has some changes made to it but it's not yet saved. This means that the state of the file has been altered from its previous state in the committed state.","title":"Modified state"},{"location":"p2/0-getting-the-base-project-ready/#staged-state","text":"A file in the staged state means it is ready to be committed. In this state, all necessary changes have been made so the next step is to move the file to the commit state. You can understand this better by imagining Git as a camera. The camera will only take a snapshot when the file reaches the commit state. After this state, the camera starts comparing changes being made to the same file with the last snapshot (this is the modified state). And when the required changes have been made, the file is staged and moved to the commit state for a new snapshot. This might be a lot of information to take in at the moment, but do not be discouraged \u2013 it gets easier with practice.","title":"Staged state"},{"location":"p2/0-getting-the-base-project-ready/#how-to-add-files-in-git","text":"When we first initialized our project, the file was not being tracked by Git. To do that, we use this command git add . The period or dot that comes after add means all the files that exist in the repository. If you want to add a specific file, maybe one named about.txt , you use git add about.txt . Now our file is in the staged state. You will not get a response after this command, but to know what state your file is in, you can run the git status command.","title":"How to add files in Git"},{"location":"p2/0-getting-the-base-project-ready/#how-to-commit-files-in-git","text":"The next state for a file after the staged state is the committed state. To commit our file, we use the git commit -m \"first commit\" command. The first part of the command git commit tells Git that all the files staged are ready to be committed so it is time to take a snapshot. The second part -m \"first commit\" is the commit message. -m is shorthand for message while the text inside the parenthesis is the commit message. After executing this command, you should get a response similar to this: Now our file is in the committed state.","title":"How to commit files in Git"},{"location":"p2/0-getting-the-base-project-ready/#step-4-push-the-repository-to-github","text":"After you create the repo, you should be redirected to a page that tells you how to create a repo locally or push an existing one. In our case, the project already exists locally so we will use commands in the \"\u2026or push an existing repository from the command line\" section. These are the commands: git remote add origin https://github.com/ihechikara/git-and-github-tutorial.git git branch -M main git push -u origin main The first command git remote add origin https://github.com/ihechikara/git-and-github-tutorial.git creates a connection between your local repo and the remote repo on Github. The URL for your remote project should be entirely different from the one above. So to follow along, make sure you are following the steps and working with your own remote repo. You won't usually get a response after executing this command but make sure you have an internet connection. The second command git branch -M main changes your main branch's name to \"main\". The default branch might be created as \"master\", but \"main\" is the standard name for this repo now. There is usually no response here. The last command git push -u origin main pushes your repo from your local device to GitHub. You should get a response similar to this: To help you deepen your understanding of file stages, I will make changes to the file and then push the new version to GitHub. Recall that our file is now in the committed state. Let's make changes to the file and take note of the states. I am going to add a new task to the to-do list: MY TO-DO LIST 1. Write an article. 2. Code. 3. Study books. 4. Attend classes on time. 5. Visit aunt. 6. Apply for remote jobs. 7. Practice code After adding the new task, run the git status command. This is what you should see: After making changes to the file, it moved to the modified state \u2013 but it's not yet staged for commit, so you can't push it to GitHub yet. Git has not taken a final snapshot of this current state as it's only comparing the changes we have made now with the last snapshot. Now we are going to add (stage) this file and then commit and push it. This is the same as in the last section. We first add the file by using git add . which adds all the files in the folder (one file in our case). Then we commit the file by running git commit -m \"added new task\" followed by git push -u origin main . Those are the three steps to pushing your modified files to GitHub. You add, commit, and then push. I hope you now understand file stages and the commands associated with them.","title":"Step 4 \u2013 Push the repository to GitHub"},{"location":"p2/0-getting-the-base-project-ready/#how-to-pull-a-repository-in-git","text":"To pull in Git means to clone a remote repository's current state into your computer/repository. This comes in handy when you want to work on your repo from a different computer or when you are contributing to an open source project online. To test this, don't worry about switching to a new computer. Just run cd .. to leave the current directory and go back one step. In my own case, I have navigated back to my desktop. Go to GitHub, and on your repository's main page you should see a green button that says \"Code\". When you click on the button, you should see some options in a dropdown menu. Go on and copy the HTTPS URL. After that, run git clone YOUR_HTTPS_URL . This command pulls the remote repository into your local computer in a folder called git-and-git-tutorial. That is:","title":"How to Pull a Repository in Git"},{"location":"p2/0-getting-the-base-project-ready/#conclusion","text":"This article covered the basic commands that'll help get you started using Git. We also started learning how to use GitHub. If you have followed up to this point then congratulations, you are good to go. You can now use Git in your projects no matter what programming language you are using. You should know that these are not all the commands that exist in Git \u2013 so feel free to do more research to learn more commands and their uses. This article and this cheat sheet are great places to start. This is a great place to see a detailed list of more Git commands.","title":"Conclusion"},{"location":"p2/1-installing-and-learning-about-archiso/","text":"Installing and Learning About ArchISO Concepts Learn about archiso package Read all the information about archiso you can find Use archiso to build an ISO yourself Analyze permissions, user and group names No local repository but instead online Preliminary Read this Article before proceeding. Course We start by reading the vision here . We need to read the article about archiso on the Arch Wiki (see preliminary) and we will set up our github on https://github.com/arcolinuxiso/. . It is a must to know what files and folders you get when installing archiso. We install archiso with this command: sudo pacman -S archiso Now you can use pamac to see what is installed where and you can go read what is installed. mkarchiso is the most important script/application that will be used later on to build the ISO. There are two profiles: baseline, and releng. We will only use the releng profile. We create a new github for Carli. We will number them to the phase we are in. We will re-use the files from our githubs. Setting up githubs is explained here . We copy/paste the releng profile inside the Carli folder and post it online to Github. Read all the files from archiso package and read the page on the arch wiki about mkinitcpio. We talk about the following files : packages.x86_64 file provides the content for the ISO mkinitcpio.conf \u2013 configuration file for your initial ramdisk pacman.conf \u2013 the repositories pacman will use and its settings airootfs \u2013 overlay for your future ISO customize_airootfs.sh \u2013 a script to change your future linux system build.sh \u2013 open it and read it We can start building with sudo ./build.sh -v Use the -v to get more information while it is building. We will add it to the script later on. There will be two extra folders. work out Now you can load this ISO into VirtualBox. If there is a work directory, you can not run the build script again. We make a cleanup script to be able to build again. We also create the file .gitignore to ensure the work folder and out folder will never go online. We check the content of our ISO by mounting it and check again on VirtualBox. Let us set the -v option by default in the build.sh","title":"Installing and Learning About ArchISO"},{"location":"p2/1-installing-and-learning-about-archiso/#installing-and-learning-about-archiso","text":"","title":"Installing and Learning About ArchISO"},{"location":"p2/1-installing-and-learning-about-archiso/#concepts","text":"Learn about archiso package Read all the information about archiso you can find Use archiso to build an ISO yourself Analyze permissions, user and group names No local repository but instead online","title":"Concepts"},{"location":"p2/1-installing-and-learning-about-archiso/#preliminary","text":"Read this Article before proceeding.","title":"Preliminary"},{"location":"p2/1-installing-and-learning-about-archiso/#course","text":"We start by reading the vision here . We need to read the article about archiso on the Arch Wiki (see preliminary) and we will set up our github on https://github.com/arcolinuxiso/. . It is a must to know what files and folders you get when installing archiso. We install archiso with this command: sudo pacman -S archiso Now you can use pamac to see what is installed where and you can go read what is installed. mkarchiso is the most important script/application that will be used later on to build the ISO. There are two profiles: baseline, and releng. We will only use the releng profile. We create a new github for Carli. We will number them to the phase we are in. We will re-use the files from our githubs. Setting up githubs is explained here . We copy/paste the releng profile inside the Carli folder and post it online to Github. Read all the files from archiso package and read the page on the arch wiki about mkinitcpio. We talk about the following files : packages.x86_64 file provides the content for the ISO mkinitcpio.conf \u2013 configuration file for your initial ramdisk pacman.conf \u2013 the repositories pacman will use and its settings airootfs \u2013 overlay for your future ISO customize_airootfs.sh \u2013 a script to change your future linux system build.sh \u2013 open it and read it We can start building with sudo ./build.sh -v Use the -v to get more information while it is building. We will add it to the script later on. There will be two extra folders. work out Now you can load this ISO into VirtualBox. If there is a work directory, you can not run the build script again. We make a cleanup script to be able to build again. We also create the file .gitignore to ensure the work folder and out folder will never go online. We check the content of our ISO by mounting it and check again on VirtualBox. Let us set the -v option by default in the build.sh","title":"Course"},{"location":"p2/getting-carli-key/","text":"Getting the Carli Keys We have a script for you to get and install the key on any Arch Linux based system. With the key you can use our packages and pacman will not throw errors at you.","title":"Getting the Carli Keys"},{"location":"p2/getting-carli-key/#getting-the-carli-keys","text":"We have a script for you to get and install the key on any Arch Linux based system. With the key you can use our packages and pacman will not throw errors at you.","title":"Getting the Carli Keys"},{"location":"p2/intro/","text":"Introduction Phase 2 In this phase you'll learn the following concepts: Learning Basics of Git and Github Working with essential tools in the CLI (Command-Line) Learning basics of archiso Learning how to build software packages","title":"Introduction"},{"location":"p2/intro/#introduction","text":"","title":"Introduction"},{"location":"p2/intro/#phase-2","text":"In this phase you'll learn the following concepts: Learning Basics of Git and Github Working with essential tools in the CLI (Command-Line) Learning basics of archiso Learning how to build software packages","title":"Phase 2"}]}